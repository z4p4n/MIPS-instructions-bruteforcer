/**
 * Fall 2014
 * CSCI 320 - Computer Architecture
 * Tiago Bozzetti, Ellie Easse and Chau Tieu
 */

var hexTable = {
    '0': '0000', '1': '0001', '2': '0010', '3': '0011', '4': '0100',
    '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001',
    'a': '1010', 'b': '1011', 'c': '1100', 'd': '1101',
    'e': '1110', 'f': '1111',
    'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101',
    'E': '1110', 'F': '1111'
};

var binaryToHexTable = {
'0000':'0','0001':'1','0010':'2','0011':'3','0100':'4',
'0101':'5','0110':'6','0111':'7','1000':'8','1001':'9',
'1010':'A','1011':'B','1100':'C','1101':'D','1110':'E',
'1111':'F'
};

var opcodeTable = {
    '000000': 'SPECIAL','000001': 'REGIMM','000010': 'J','000011': 'JAL','000100': 'BEQ',
    '000101': 'BNE','000110': 'BLEZ','000111': 'BGTZ','001000': 'ADDI','001001': 'ADDIU',
    '001010': 'SLTI','001011': 'SLTIU','001100': 'ANDI','001101': 'ORI','001110': 'XORI',
    '001111': 'LUI','010000': 'COP0','010001': 'COP1','010010': 'COP2','010011': 'COP3',
    '010100': 'BEQL','010101': 'BNEL','010110': 'BLEZL','010111': 'BGTZL','011000': 'DADDI',
    '011001': 'DADDIU','100000': 'LB','100001': 'LH','100010': 'LWL','100011': 'LW',
    '100100': 'LBU','100101': 'LHU','100110': 'LWR','101000': 'SB','101001': 'SH',
    '101010': 'SWL','101011': 'SW','101110': 'SWR','101111': 'CACHE','110000': 'LLU',
    '110001': 'LWC1','110010': 'LWC2','110011': 'LWC3','110101': 'LDC1','110110': 'LDC2',
    '110111': 'LDC3','111000': 'SC','111001': 'SWC1','111010': 'SWC2','111011': 'SWC3',
    '111101': 'SDC1','111110': 'SDC2','111111': 'SDC3'
};


var functTable = {
    '000000': 'SLL','000010': 'SRL','000011': 'SRA','000100': 'SLLV','000110': 'SRLV',
    '000111': 'SRAV','001000': 'JR','001001': 'JALR','001100': 'SYSCALL','001101': 'BREAK',
    '010000': 'MFHI','010001': 'MTHI','010010': 'MFLO','010011': 'MTLO','010100': 'DSLLV',
    '010111': 'DSRAV','011000': 'MULT','011001': 'MULTU','011010': 'DIV','011011': 'DIVU',
    '011100': 'DMULT','011101': 'DMULTU','011110': 'DDIV','011111': 'DDIVU','100000': 'ADD',
    '100001': 'ADDU','100010': 'SUB','100011': 'SUBU','100100': 'AND','100101': 'OR',
    '100110': 'XOR','100111': 'NOR','101010': 'SLT','101011': 'SLTU','101100': 'DADD',
    '101101': 'DADDU','110000': 'TGE','110001': 'TGEU','110010': 'TLT','110011': 'TLTU',
    '110100': 'TEQ','110110': 'TNE','111000': 'DSLL','111010': 'DSRL','111011': 'DSRA',
    '111100': 'DSLL32','111110': 'DSRL32','111111': 'DSRA32'
};


var regimmTable = {
    '00000': 'BLTZ','00001': 'BGEZ','00010': 'BLTZL','00011': 'BGEZL','01000': 'TGEI',
    '01001': 'TGEIU','01010': 'TLTI','01011': 'TLTIU','01100': 'TEQI','01110': 'TNEI',
    '10000': 'BLTZAL','10001': 'BGEZAL','10010': 'BLTZALL','10011': 'BGEZALL'
};


var regNames = ['$zero', '$at', '$v0', '$v1', '$a0', '$a1', '$a2', '$a3', '$t0',  '$t1', '$t2','$t3', '$t4', '$t5','$t6', '$t7', '$s0', '$s1', '$s2', '$s3', '$s4', '$s5', '$s6', '$s7', '$t8', '$t9', '$k0', '$k1', '$gp', '$sp', '$fp', '$ra'];


var registerTable = {
    '00000': '$zero', '00001': '$at', '00010': '$v0', '00011': '$v1', 
    '00100': '$a0','00101': '$a1', '00110': '$a2', '00111': '$a3',
    '01000': '$t0', '01001': '$t1','01010': '$t2', '01011': '$t3', 
    '01100': '$t4', '01101': '$t5','01110': '$t6', '01111': '$t7',
    '10000': '$s0', '10001': '$s1', '10010': '$s2', '10011': '$s3',
    '10100': '$s4', '10101': '$s5', '10110': '$s6', '10111': '$s7',
    '11000': '$t8', '11001': '$t9', '11010': '$k0', '11011': '$k1',
    '11100': '$gp', '11101': '$sp', '11110': '$fp', '11111': '$ra' 
};

var instructions = [{symbol: "ADD", name: "Add Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "ADD", "100000"]], format: "ADD rd, rs, rt [R-type]", purpose: "To add 32-bit integers. If overflow occurs, then trap.", description: "rd <- rs + rt<br>The 32-bit word value in GPR rt is added to the 32-bit value in GPR rs to produce a 32-bit result. If the addition results in 32-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 32-bit result is placed into GPR rd.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>temp <- GPR[rs] + GPR[rt]<br>if (32_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rd] <- sign_extend(temp31..0)<br>endif", exceptions: "Integer Overflow", programming_notes: "ADDU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "ADDI", name: "Add Immediate Word", architecture: "MIPS I", bits: [[31, 26, "ADDI", "001000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "ADDI rt, rs, immediate [I-type]", purpose: "To add a constant to a 32-bit integer. If overflow occurs, then trap.", description: "rt <- rs + immediate<br>The 16-bit signed immediate is added to the 32-bit value in GPR rs to produce a 32-bit result. If the addition results in 32-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 32-bit result is placed into GPR rt.", restrictions: "On 64-bit processors, if GPR rs does not contain a sign-extended 32-bit value (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs])) then UndefinedResult() endif<br>temp <- GPR[rs] + sign_extend(immediate)<br>if (32_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rt] <- sign_extend(temp31..0)<br>endif", exceptions: "Integer Overflow", programming_notes: "ADDIU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "ADDIU", name: "Add Immediate Unsigned Word", architecture: "MIPS I", bits: [[31, 26, "ADDIU", "001001"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "ADDIU rt, rs, immediate [I-type]", purpose: "To add a constant to a 32-bit integer.", description: "rt <- rs + immediate<br>The 16-bit signed immediate is added to the 32-bit value in GPR rs and the 32-bit arithmetic result is placed into GPR rt.<br>No Integer Overflow exception occurs under any circumstances.", restrictions: "On 64-bit processors, if GPR rs does not contain a sign-extended 32-bit value (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs])) then UndefinedResult() endif<br>temp <- GPR[rs] + sign_extend(immediate)<br>GPR[rt] <- sign_extend(temp31..0)", exceptions: "None.", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 32-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "ADDU", name: "Add Unsigned Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "ADDU", "100001"]], format: "ADDU rd, rs, rt [R-type]", purpose: "To add 32-bit integers.", description: "rd <- rs + rt<br>The 32-bit word value in GPR rt is added to the 32-bit value in GPR rs and the 32-bit arithmetic result is placed into GPR rd.<br>No Integer Overflow exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>temp <- GPR[rs] + GPR[rt]<br>GPR[rd] <- sign_extend(temp31..0)", exceptions: "None.", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 32-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "AND", name: "And", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "AND", "100100"]], format: "AND rd, rs, rt [R-type]", purpose: "To do a bitwise logical AND.", description: "rd <- rs AND rt<br>The contents of GPR rs are combined with the contents of GPR rt in a bitwise logical AND operation. The result is placed into GPR rd.", restrictions: "None.", operation: "GPR[rd] <- GPR[rs] and GPR[rt]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "ANDI", name: "And Immediate", architecture: "MIPS I", bits: [[31, 26, "ANDI", "001100"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "ANDI rt, rs, immediate [I-type]", purpose: "To do a bitwise logical AND with a constant.", description: "rt <- rs AND immediate<br>The 16-bit immediate is zero-extended to the left and combined with the contents of GPR rs in a bitwise logical AND operation. The result is placed into GPR rt.", restrictions: "None.", operation: "GPR[rt] <- zero_extend(immediate) and GPR[rs]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "BEQ", name: "Branch on Equal", architecture: "MIPS I", bits: [[31, 26, "BEQ", "000100"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "BEQ rs, rt, offset [I-type]", purpose: "To compare GPRs then do a PC-relative conditional branch.", description: "if (rs = rt) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs and GPR rt are equal, branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- (GPR[rs] = GPR[rt])<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BEQL", name: "Branch on Equal Likely", architecture: "MIPS II", bits: [[31, 26, "BEQL", "010100"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "BEQL rs, rt, offset [I-type]", purpose: "To compare GPRs then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs = rt) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs and GPR rt are equal, branch to the target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- (GPR[rs] = GPR[rt])<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BGEZ", name: "Branch on Greater Than or Equal to Zero", architecture: "MIPS I", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BGEZ", "00001"],[15, 0, "offset", ""]], format: "BGEZ rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch.", description: "if (rs >= 0) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] >= 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BGEZAL", name: "Branch on Greater Than or Equal to Zero and Link", architecture: "MIPS I", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BGEZAL", "10001"],[15, 0, "offset", ""]], format: "BGEZAL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional procedure call.", description: "if (rs >= 0) then procedure_call<br>Place the return address link in GPR 31. The return link is the address of the second instruction following the branch, where execution would continue after a procedure call.<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "GPR 31 must not be used for the source register rs, because such an instruction does not have the same effect when re-executed. The result of executing such an instruction is undefined. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] >= 0GPRLEN<br>&emsp;GPR[31] <- PC + 8<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump and link (JAL) or jump and link register (JALR) instructions for procedure calls to more distant addresses.", implementation_notes: ""},
{symbol: "BGEZALL", name: "Branch on Greater Than or Equal to Zero and Link Likely", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BGEZALL", "10011"],[15, 0, "offset", ""]], format: "BGEZALL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional procedure call; execute the delay slot only if the branch is taken.", description: "if (rs >= 0) then procedure_call_likely<br>Place the return address link in GPR 31. The return link is the address of the second instruction following the branch, where execution would continue after a procedure call.<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "GPR 31 must not be used for the source register rs, because such an instruction does not have the same effect when re-executed. The result of executing such an instruction is undefined. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] >= 0GPRLEN<br>&emsp;GPR[31] <- PC + 8<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump and link (JAL) or jump and link register (JALR) instructions for procedure calls to more distant addresses.", implementation_notes: ""},
{symbol: "BGEZL", name: "Branch on Greater Than or Equal to Zero Likely", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BGEZL", "00011"],[15, 0, "offset", ""]], format: "BGEZL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs >= 0) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than or equal to zero (sign bit is 0), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] >= 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BGTZ", name: "Branch on Greater Than Zero", architecture: "MIPS I", bits: [[31, 26, "BGTZ", "000111"],[25, 21, "rs", ""],[20, 16, "0", "00000"],[15, 0, "offset", ""]], format: "BGTZ rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch.", description: "if (rs > 0) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than zero (sign bit is 0 but value not zero), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] > 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BGTZL", name: "Branch on Greater Than Zero Likely", architecture: "MIPS II", bits: [[31, 26, "BGTZL", "010111"],[25, 21, "rs", ""],[20, 16, "0", "00000"],[15, 0, "offset", ""]], format: "BGTZL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs > 0) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are greater than zero (sign bit is 0 but value not zero), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] > 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BLEZ", name: "Branch on Less Than or Equal to Zero", architecture: "MIPS I", bits: [[31, 26, "BLEZ", "000110"],[25, 21, "rs", ""],[20, 16, "0", "00000"],[15, 0, "offset", ""]], format: "BLEZ rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch.", description: "if (rs <= 0) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than or equal to zero (sign bit is 1 or value is zero), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] <= 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BLEZL", name: "Branch on Less Than or Equal to Zero Likely", architecture: "MIPS II", bits: [[31, 26, "BLEZL", "010110"],[25, 21, "rs", ""],[20, 16, "0", "00000"],[15, 0, "offset", ""]], format: "BLEZL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs <= 0) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than or equal to zero (sign bit is 1 or value is zero), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] <= 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BLTZ", name: "Branch on Less Than Zero", architecture: "MIPS I", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BLTZ", "00000"],[15, 0, "offset", ""]], format: "BLTZ rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch.", description: "if (rs < 0) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] < 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BLTZAL", name: "Branch on Less Than Zero And Link", architecture: "MIPS I", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BLTZAL", "10000"],[15, 0, "offset", ""]], format: "BLTZAL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional procedure call.", description: "if (rs < 0) then procedure_call<br>Place the return address link in GPR 31. The return link is the address of the second instruction following the branch (not the branch itself), where execution would continue after a procedure call.<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch, in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "GPR 31 must not be used for the source register rs, because such an instruction does not have the same effect when re-executed. The result of executing such an instruction is undefined. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] < 0GPRLEN<br>&emsp;GPR[31] <- PC + 8<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump and link (JAL) or jump and link register (JALR) instructions for procedure calls to more distant addresses.", implementation_notes: ""},
{symbol: "BLTZALL", name: "Branch on Less Than Zero And Link Likely", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BLTZALL", "10010"],[15, 0, "offset", ""]], format: "BLTZALL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional procedure call; execute the delay slot only if the branch is taken.", description: "if (rs < 0) then procedure_call_likely<br>Place the return address link in GPR 31. The return link is the address of the second instruction following the branch (not the branch itself), where execution would continue after a procedure call.<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch, in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "GPR 31 must not be used for the source register rs, because such an instruction does not have the same effect when re-executed. The result of executing such an instruction is undefined. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] < 0GPRLEN<br>&emsp;GPR[31] <- PC + 8<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump and link (JAL) or jump and link register (JALR) instructions for procedure calls to more distant addresses.", implementation_notes: ""},
{symbol: "BLTZL", name: "Branch on Less Than Zero Likely", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "BLTZL", "00010"],[15, 0, "offset", ""]], format: "BLTZL rs, offset [I-type]", purpose: "To test a GPR then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs < 0) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs are less than zero (sign bit is 1), branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- GPR[rs] < 0GPRLEN<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BNE", name: "Branch on Not Equal", architecture: "MIPS I", bits: [[31, 26, "BNE", "000101"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "BNE rs, rt, offset [I-type]", purpose: "To compare GPRs then do a PC-relative conditional branch.", description: "if (rs !=  rt) then branch<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs and GPR rt are not equal, branch to the effective target address after the instruction in the delay slot is executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- (GPR[rs] !=  GPR[rt])<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;endif", exceptions: "None.", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BNEL", name: "Branch on Not Equal Likely", architecture: "MIPS II", bits: [[31, 26, "BNEL", "010101"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "BNEL rs, rt, offset [I-type]", purpose: "To compare GPRs then do a PC-relative conditional branch; execute the delay slot only if the branch is taken.", description: "if (rs !=  rt) then branch_likely<br>An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is added to the address of the instruction following the branch (not the branch itself), in the branch delay slot, to form a PC-relative effective target address.<br>If the contents of GPR rs and GPR rt are not equal, branch to the effective target address after the instruction in the delay slot is executed. If the branch is not taken, the instruction in the delay slot is not executed.", restrictions: "None.", operation: "I:<br>&emsp;tgt_offset <- sign_extend(offset || 02)<br>&emsp;condition <- (GPR[rs] !=  GPR[rt])<br>I+1:<br>&emsp;if condition then<br>&emsp;&emsp;PC <- PC + tgt_offset<br>&emsp;else<br>&emsp;&emsp;NullifyCurrentInstruction()<br>&emsp;endif", exceptions: "Reserved Instruction", programming_notes: "With the 18-bit signed instruction offset, the conditional branch range is ± 128 KBytes. Use jump (J) or jump register (JR) instructions to branch to more distant addresses.", implementation_notes: ""},
{symbol: "BREAK", name: "Breakpoint", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 6, "code", ""],[5, 0, "BREAK", "001101"]], format: "BREAK [R-type]", purpose: "To cause a Breakpoint exception.", description: "A breakpoint exception occurs, immediately and unconditionally transferring control to the exception handler.<br>The code field is available for use as software parameters, but is retrieved by the exception handler only by loading the contents of the memory word containing the instruction.", restrictions: "None.", operation: "SignalException(Breakpoint)", exceptions: "Breakpoint", programming_notes: "", implementation_notes: ""},
{symbol: "COP0", name: "Coprocessor Operation", architecture: "MIPS I", bits: [[31, 26, "COP0", "010000"],[25, 0, "cop_fun", ""]], format: "COP0 cop_fun [I-type]", purpose: "To execute a coprocessor instruction.", description: "The coprocessor operation specified by cop_fun is performed by coprocessor unit 0. Details of coprocessor operations must be found in the specification for each coprocessor.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>See specification for the specific coprocessor being programmed.", operation: "CoprocessorOperation (0, cop_fun)", exceptions: "Reserved Instruction<br>Coprocessor Unusable<br>Coprocessor interrupt or Floating-Point Exception (CP1 only for some processors)", programming_notes: "", implementation_notes: ""},
{symbol: "COP1", name: "Coprocessor Operation", architecture: "MIPS I", bits: [[31, 26, "COP1", "010001"],[25, 0, "cop_fun", ""]], format: "COP1 cop_fun [I-type]", purpose: "To execute a coprocessor instruction.", description: "The coprocessor operation specified by cop_fun is performed by coprocessor unit 1. Details of coprocessor operations must be found in the specification for each coprocessor.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>See specification for the specific coprocessor being programmed.", operation: "CoprocessorOperation (1, cop_fun)", exceptions: "Reserved Instruction<br>Coprocessor Unusable<br>Coprocessor interrupt or Floating-Point Exception (CP1 only for some processors)", programming_notes: "", implementation_notes: ""},
{symbol: "COP2", name: "Coprocessor Operation", architecture: "MIPS I", bits: [[31, 26, "COP2", "010010"],[25, 0, "cop_fun", ""]], format: "COP2 cop_fun [I-type]", purpose: "To execute a coprocessor instruction.", description: "The coprocessor operation specified by cop_fun is performed by coprocessor unit 2. Details of coprocessor operations must be found in the specification for each coprocessor.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>See specification for the specific coprocessor being programmed.", operation: "CoprocessorOperation (2, cop_fun)", exceptions: "Reserved Instruction<br>Coprocessor Unusable<br>Coprocessor interrupt or Floating-Point Exception (CP1 only for some processors)", programming_notes: "", implementation_notes: ""},
{symbol: "COP3", name: "Coprocessor Operation", architecture: "MIPS I", bits: [[31, 26, "COP3", "010011"],[25, 0, "cop_fun", ""]], format: "COP3 cop_fun [I-type]", purpose: "To execute a coprocessor instruction.", description: "The coprocessor operation specified by cop_fun is performed by coprocessor unit 3. Details of coprocessor operations must be found in the specification for each coprocessor.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>See specification for the specific coprocessor being programmed.", operation: "CoprocessorOperation (3, cop_fun)", exceptions: "Reserved Instruction<br>Coprocessor Unusable<br>Coprocessor interrupt or Floating-Point Exception (CP1 only for some processors)", programming_notes: "", implementation_notes: ""},
{symbol: "DADD", name: "Doubleword Add", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DADD", "101100"]], format: "DADD rd, rs, rt [R-type]", purpose: "To add 64-bit integers. If overflow occurs, then trap.", description: "rd <- rs + rt<br>The 64-bit doubleword value in GPR rt is added to the 64-bit value in GPR rs to produce a 64-bit result. If the addition results in 64-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 64-bit result is placed into GPR rd.", restrictions: "None.", operation: "64-bit processors:<br>temp <- GPR[rs] + GPR[rt]<br>if (64_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rd] <- temp<br>endif", exceptions: "Integer Overflow<br>Reserved Instruction", programming_notes: "DADDU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "DADDI", name: "Doubleword Add Immediate", architecture: "MIPS III", bits: [[31, 26, "DADDI", "011000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "DADDI rt, rs, immediate [I-type]", purpose: "To add a constant to a 64-bit integer. If overflow occurs, then trap.", description: "rt <- rs + immediate<br>The 16-bit signed immediate is added to the 64-bit value in GPR rs to produce a 64-bit result. If the addition results in 64-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 64-bit result is placed into GPR rt.", restrictions: "None.", operation: "64-bit processors:<br>temp <- GPR[rs] + sign_extend(immediate)<br>if (64_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rt] <- temp<br>endif", exceptions: "Integer Overflow<br>Reserved Instruction", programming_notes: "DADDIU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "DADDIU", name: "Doubleword Add Immediate Unsigned", architecture: "MIPS III", bits: [[31, 26, "DADDIU", "011001"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "DADDIU rt, rs, immediate [I-type]", purpose: "To add a constant to a 64-bit integer.", description: "rt <- rs + immediate<br>The 16-bit signed immediate is added to the 64-bit value in GPR rs and the 64-bit arithmetic result is placed into GPR rt.<br>No Integer Overflow exception occurs under any circumstances.", restrictions: "None.", operation: "64-bit processors:<br>GPR[rt] <- GPR[rs] + sign_extend(immediate)", exceptions: "Reserved Instruction", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 64-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "DADDU", name: "Doubleword Add Unsigned", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DADDU", "101101"]], format: "DADDU rd, rs, rt [R-type]", purpose: "To add 64-bit integers.", description: "rd <- rs + rt<br>The 64-bit doubleword value in GPR rt is added to the 64-bit value in GPR rs and the 64-bit arithmetic result is placed into GPR rd.<br>No Integer Overflow exception occurs under any circumstances.", restrictions: "None.", operation: "64-bit processors:<br>GPR[rd] <- GPR[rs] + GPR[rt]", exceptions: "Reserved Instruction", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 64-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "DDIV", name: "Doubleword Divide", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DDIV", "011110"]], format: "DDIV rs, rt [R-type]", purpose: "To divide 64-bit signed integers.", description: "(LO, HI) <- rs / rt<br>The 64-bit doubleword in GPR rs is divided by the 64-bit doubleword in GPR rt, treating both operands as signed values. The 64-bit quotient is placed into special register LO and the 64-bit remainder is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.<br>If the divisor in GPR rt is zero, the arithmetic result value is undefined.", operation: "64-bit processors:<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined<br>I:<br>&emsp;LO <- GPR[rs] div GPR[rt]<br>&emsp;HI <- GPR[rs] mod GPR[rt]", exceptions: "Reserved Instruction", programming_notes: "See the Programming Notes for the DIV instruction.", implementation_notes: ""},
{symbol: "DDIVU", name: "Doubleword Divide Unsigned", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DDIVU", "011111"]], format: "DDIVU rs, rt [R-type]", purpose: "To divide 64-bit unsigned integers.", description: "(LO, HI) <- rs / rt<br>The 64-bit doubleword in GPR rs is divided by the 64-bit doubleword in GPR rt, treating both operands as unsigned values. The 64-bit quotient is placed into special register LO and the 64-bit remainder is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.<br>If the divisor in GPR rt is zero, the arithmetic result value is undefined.", operation: "64-bit processors:<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined      <br>I:<br>&emsp;LO <- (0 || GPR[rs]) div (0 || GPR[rt])               <br>&emsp;HI <- (0 || GPR[rs]) mod (0 || GPR[rt])", exceptions: "Reserved instruction", programming_notes: "See the Programming Notes for the DIV instruction.", implementation_notes: ""},
{symbol: "DIV", name: "Divide Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DIV", "011010"]], format: "DIV rs, rt [R-type]", purpose: "To divide 32-bit signed integers.", description: "(LO, HI) <- rs / rt<br>The 32-bit word value in GPR rs is divided by the 32-bit value in GPR rt, treating both operands as signed values. The 32-bit quotient is placed into special register LO and the 32-bit remainder is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.<br>If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.<br>If the divisor in GPR rt is zero, the arithmetic result value is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined                       <br>I:<br>&emsp;q <- GPR[rs]31..0 div GPR[rt]31..0                                <br>&emsp;LO <- sign_extend(q31..0)                        <br>&emsp;r <- GPR[rs]31..0 mod GPR[rt]31..0                     <br>&emsp;HI <- sign_extend(r31..0)", exceptions: "None.", programming_notes: "In some processors the integer divide operation may proceed asynchronously and allow other CPU instructions to execute before it is complete. An attempt to read LO or HI before the results are written will wait (interlock) until the results are ready. Asynchronous execution does not affect the program result, but offers an opportunity for performance improvement by scheduling the divide so that other instructions can execute in parallel.<br>No arithmetic exception occurs under any circumstances. If divide-by-zero or overflow conditions should be detected and some action taken, then the divide instruction is typically followed by additional instructions to check for a zero divisor and/or for overflow. If the divide is asynchronous then the zero-divisor check can execute in parallel with the divide. The action taken on either divide-by-zero or overflow is either a convention within the program itself or more typically, the system software; one possibility is to take a BREAK exception with a code field value to signal the problem to the system software.<br>As an example, the C programming language in a UNIX environment expects division by zero to either terminate the program or execute a program-specified signal handler. C does not expect overflow to cause any exceptional condition. If the C compiler uses a divide instruction, it also emits code to test for a zero divisor and execute a BREAK instruction to inform the operating system if one is detected.", implementation_notes: ""},
{symbol: "DIVU", name: "Divide Unsigned Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DIVU", "011011"]], format: "DIVU rs, rt [R-type]", purpose: "To divide 32-bit unsigned integers.", description: "(LO, HI) <- rs / rt<br>The 32-bit word value in GPR rs is divided by the 32-bit value in GPR rt, treating both operands as unsigned values. The 32-bit quotient is placed into special register LO and the 32-bit remainder is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.<br>If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them, like this one, by two or more other instructions.<br>If the divisor in GPR rt is zero, the arithmetic result is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined<br>I:<br>&emsp;q <- (0 || GPR[rs]31..0) div (0 || GPR[rt]31..0)<br>&emsp;LO <- sign_extend(q31..0)<br>&emsp;r <- (0 || GPR[rs]31..0) mod (0 || GPR[rt]31..0)<br>&emsp;HI <- sign_extend(r31..0)", exceptions: "None.", programming_notes: "See the Programming Notes for the DIV instruction.", implementation_notes: ""},
{symbol: "DMULT", name: "Doubleword Multiply", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DMULT", "011100"]], format: "DMULT rs, rt [R-type]", purpose: "To multiply 64-bit signed integers.", description: "(LO, HI) <- rs * rt<br>The 64-bit doubleword value in GPR rt is multiplied by the 64-bit value in GPR rs, treating both operands as signed values, to produce a 128-bit result. The low-order 64-bit doubleword of the result is placed into special register LO, and the high-order 64-bit doubleword is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.", operation: "64-bit processors:<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined<br>I:<br>&emsp;prod <- GPR[rs] * GPR[rt]<br>&emsp;LO <- prod63..0<br>&emsp;HI <- prod127..64", exceptions: "Reserved Instruction", programming_notes: "In some processors the integer multiply operation may proceed asynchronously and allow other CPU instructions to execute before it is complete. An attempt to read LO or HI before the results are written will wait (interlock) until the results are ready. Asynchronous execution does not affect the program result, but offers an opportunity for performance improvement by scheduling the multiply so that other instructions can execute in parallel.<br>Programs that require overflow detection must check for it explicitly.", implementation_notes: ""},
{symbol: "DMULTU", name: "Doubleword Multiply Unsigned", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "DMULTU", "011101"]], format: "DMULTU rs, rt [R-type]", purpose: "To multiply 64-bit unsigned integers.", description: "(LO, HI) <- rs * rt<br>The 64-bit doubleword value in GPR rt is multiplied by the 64-bit value in GPR rs, treating both operands as unsigned values, to produce a 128-bit result. The low-order 64-bit doubleword of the result is placed into special register LO, and the high-order 64-bit doubleword is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.", operation: "64-bit processors:<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined        <br>I:<br>&emsp;prod <- (0 || GPR[rs]) * (0 || GPR[rt])<br>&emsp;LO <- prod63..0<br>&emsp;HI <- prod127..64", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSLL", name: "Doubleword Shift Left Logical", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSLL", "111000"]], format: "DSLL rd, rt, sa [R-type]", purpose: "To left shift a doubleword by a fixed amount -- 0 to 31 bits.", description: "rd <- rt << sa<br>The 64-bit doubleword contents of GPR rt are shifted left, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 31 is specified by sa.", restrictions: "None.", operation: "64-bit processors:<br>s <- 0 || sa<br>GPR[rd] <- GPR[rt](63-s)..0 || 0s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSLL32", name: "Doubleword Shift Left Logical Plus 32", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSLL32", "111100"]], format: "DSLL32 rd, rt, sa [R-type]", purpose: "To left shift a doubleword by a fixed amount -- 32 to 63 bits.", description: "rd <- rt << (sa+32)<br>The 64-bit doubleword contents of GPR rt are shifted left, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 32 to 63 is specified by sa+32.", restrictions: "None.", operation: "64-bit processors:<br>s <- 1 || sa /* 32+sa */<br>GPR[rd] <- GPR[rt](63-s)..0 || 0s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSLLV", name: "Doubleword Shift Left Logical Variable", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DSLLV", "010100"]], format: "DSLLV rd, rt, rs [R-type]", purpose: "To left shift a doubleword by a variable number of bits.", description: "rd <- rt << rs<br>The 64-bit doubleword contents of GPR rt are shifted left, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 63 is specified by the low-order six bits in GPR rs.", restrictions: "None.", operation: "64-bit processors:<br>s <- 0 || GPR[rs]5..0<br>GPR[rd] <- GPR[rt](63-s)..0 || 0s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRA", name: "Doubleword Shift Right Arithmetic", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSRA", "111011"]], format: "DSRA rd, rt, sa [R-type]", purpose: "To arithmetic right shift a doubleword by a fixed amount -- 0 to 31 bits.", description: "rd <- rt >> sa (arithmetic)<br>The 64-bit doubleword contents of GPR rt are shifted right, duplicating the sign bit (63) into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 31 is specified by sa.", restrictions: "None.", operation: "64-bit processors:<br>s <- 0 || sa<br>GPR[rd] <- (GPR[rt]63)s || GPR[rt] 63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRA32", name: "Doubleword Shift Right Arithmetic Plus 32", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSRA32", "111111"]], format: "DSRA32 rd, rt, sa [R-type]", purpose: "To arithmetic right shift a doubleword by a fixed amount -- 32-63 bits.", description: "rd <- rt >> (sa+32) (arithmetic)<br>The doubleword contents of GPR rt are shifted right, duplicating the sign bit (63) into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 32 to 63 is specified by sa+32.", restrictions: "None.", operation: "64-bit processors:<br>s <- 1 || sa /* 32+sa */<br>GPR[rd] <- (GPR[rt]63)s || GPR[rt]63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRAV", name: "Doubleword Shift Right Arithmetic Variable", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DSRAV", "010111"]], format: "DSRAV rd, rt, rs [R-type]", purpose: "To arithmetic right shift a doubleword by a variable number of bits.", description: "rd <- rt >> rs (arithmetic)<br>The doubleword contents of GPR rt are shifted right, duplicating the sign bit (63) into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 63 is specified by the low-order six bits in GPR rs.", restrictions: "None.", operation: "64-bit processors:<br>s <- GPR[rs]5..0<br>GPR[rd] <- (GPR[rt]63)s || GPR[rt]63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRL", name: "Doubleword Shift Right Logical", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSRL", "111010"]], format: "DSRL rd, rt, sa [R-type]", purpose: "To logical right shift a doubleword by a fixed amount -- 0 to 31 bits.", description: "rd <- rt >> sa (logical)<br>The doubleword contents of GPR rt are shifted right, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 31 is specified by sa.", restrictions: "None.", operation: "64-bit processors:<br>s <- 0 || sa<br>GPR[rd] <- 0s || GPR[rt]63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRL32", name: "Doubleword Shift Right Logical Plus 32", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "DSRL32", "111110"]], format: "DSRL32 rd, rt, sa [R-type]", purpose: "To logical right shift a doubleword by a fixed amount -- 32 to 63 bits.", description: "rd <- rt >> (sa+32) (logical)<br>The 64-bit doubleword contents of GPR rt are shifted right, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 32 to 63 is specified by sa+32.", restrictions: "None.", operation: "64-bit processors:<br>s <- 1 || sa /* 32+sa */<br>GPR[rd] <- 0s || GPR[rt]63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSRLV", name: "Doubleword Shift Right Logical Variable", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DSRLV", "010110"]], format: "DSRLV rd, rt, rs [R-type]", purpose: "To logical right shift a doubleword by a variable number of bits.", description: "rd <- rt >> rs (logical)<br>The 64-bit doubleword contents of GPR rt are shifted right, inserting zeros into the emptied bits; the result is placed in GPR rd. The bit shift count in the range 0 to 63 is specified by the low-order six bits in GPR rs.", restrictions: "None.", operation: "64-bit processors:<br>s <- GPR[rs]5..0<br>GPR[rd] <- 0s || GPR[rt]63..s", exceptions: "Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "DSUB", name: "Doubleword Subtract", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DSUB", "101110"]], format: "DSUB rd, rs, rt [R-type]", purpose: "To subtract 64-bit integers; trap if overflow.", description: "rd <- rs - rt<br>The 64-bit doubleword value in GPR rt is subtracted from the 64-bit value in GPR rs to produce a 64-bit result. If the subtraction results in 64-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 64-bit result is placed into GPR rd.", restrictions: "None.", operation: "64-bit processors:<br>temp <- GPR[rs] - GPR[rt]<br>if (64_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rd] <- temp<br>endif", exceptions: "Integer Overflow<br>Reserved Instruction", programming_notes: "DSUBU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "DSUBU", name: "Doubleword Subtract Unsigned", architecture: "MIPS III", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "DSUBU", "101111"]], format: "DSUBU rd, rs, rt [R-type]", purpose: "To subtract 64-bit integers.", description: "rd <- rs - rt<br>The 64-bit doubleword value in GPR rt is subtracted from the 64-bit value in GPR rs and the 64-bit arithmetic result is placed into GPR rd.<br>No Integer Overflow exception occurs under any circumstances.", restrictions: "None.", operation: "64-bit processors:<br>GPR[rd] <- GPR[rs] - GPR[rt]", exceptions: "Reserved Instruction", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 64-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "J", name: "Jump", architecture: "MIPS I", bits: [[31, 26, "J", "000010"],[25, 0, "target", ""]], format: "J target [J-type]", purpose: "To branch within the current 256 MB aligned region.", description: "This is a PC-region branch (not PC-relative); the effective target address is in the \"current\" 256 MB aligned region. The low 28 bits of the target address is the instr_index field shifted left 2 bits. The remaining upper bits are the corresponding bits of the address of the instruction in the delay slot (not the branch itself).<br>Jump to the effective target address. Execute the instruction following the jump, in the branch delay slot, before jumping.", restrictions: "None.", operation: "I:<br>I+1:<br>&emsp;PC <- PCGPRLEN..28 || instr_index || 02", exceptions: "None.", programming_notes: "Forming the branch target address by catenating PC and index bits rather than adding a signed offset to the PC is an advantage if all program code addresses fit into a 256 MB region aligned on a 256 MB boundary. It allows a branch to anywhere in the region from anywhere in the region which a signed relative offset would not allow.   <br>This definition creates the boundary case where the branch instruction is in the last word of a 256 MB region and can therefore only branch to the following 256 MB region containing the branch delay slot.", implementation_notes: ""},
{symbol: "JAL", name: "Jump And Link", architecture: "MIPS I", bits: [[31, 26, "JAL", "000011"],[25, 0, "target", ""]], format: "JAL target [J-type]", purpose: "To procedure call within the current 256 MB aligned region.", description: "Place the return address link in GPR 31. The return link is the address of the second instruction following the branch, where execution would continue after a procedure call.<br>This is a PC-region branch (not PC-relative); the effective target address is in the \"current\" 256 MB aligned region. The low 28 bits of the target address is the instr_index field shifted left 2 bits. The remaining upper bits are the corresponding bits of the address of the instruction in the delay slot (not the branch itself).<br>Jump to the effective target address. Execute the instruction following the jump, in the branch delay slot, before jumping.", restrictions: "None.", operation: "I:<br>&emsp;GPR[31] <- PC + 8<br>I+1:<br>&emsp;PC <- PCGPRLEN..28 || instr_index || 02", exceptions: "None.", programming_notes: "Forming the branch target address by catenating PC and index bits rather than adding a signed offset to the PC is an advantage if all program code addresses fit into a 256 MB region aligned on a 256 MB boundary. It allows a branch to anywhere in the region from anywhere in the region which a signed relative offset would not allow. <br>This definition creates the boundary case where the branch instruction is in the last word of a 256 MB region and can therefore only branch to the following 256 MB region containing the branch delay slot.", implementation_notes: ""},
{symbol: "JALR", name: "Jump And Link Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "0", "00000"],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "JALR", "001001"]], format: "JALR rd, rs [R-type]", purpose: "To procedure call to an instruction address in a register.", description: "rd <- return_addr, PC <- rs<br>Place the return address link in GPR rd. The return link is the address of the second instruction following the branch, where execution would continue after a procedure call.<br>Jump to the effective target address in GPR rs. Execute the instruction following the jump, in the branch delay slot, before jumping.", restrictions: "Register specifiers rs and rd must not be equal, because such an instruction does not have the same effect when re-executed. The result of executing such an instruction is undefined. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.<br>The effective target address in GPR rs must be naturally aligned. If either of the two least-significant bits are not -zero, then an Address Error exception occurs, not for the jump instruction, but when the branch target is subsequently fetched as an instruction.", operation: "I:<br>&emsp;temp <- GPR[rs]<br>&emsp;GPR[rd] <- PC + 8<br>I+1:<br>&emsp;PC <- temp", exceptions: "None.", programming_notes: "This is the only branch-and-link instruction that can select a register for the return link; all other link instructions use GPR 31 The default register for GPR rd, if omitted in the assembly language instruction, is GPR 31.", implementation_notes: ""},
{symbol: "JR", name: "Jump Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 6, "0", "000000000000000"],[5, 0, "JR", "001000"]], format: "JR rs [R-type]", purpose: "To branch to an instruction address in a register.", description: "PC <- rs<br>Jump to the effective target address in GPR rs. Execute the instruction following the jump, in the branch delay slot, before jumping.", restrictions: "The effective target address in GPR rs must be naturally aligned. If either of the two least-significant bits are not zero, then an Address Error exception occurs, not for the jump instruction, but when the branch target is subsequently fetched as an instruction.", operation: "I:<br>&emsp;temp <- GPR[rs]<br>I+1:<br>&emsp;PC <- temp", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "LB", name: "Load Byte", architecture: "MIPS I", bits: [[31, 26, "LB", "100000"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LB rt, offset(base) [I-type]", purpose: "To load a byte from memory as a signed value.", description: "rt <- memory[base+offset]<br>The contents of the 8-bit byte at the memory location specified by the effective address are fetched, sign-extended, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "None.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1).. 2 || (pAddr1..0 xor ReverseEndian2)<br>memword <- LoadMemory (uncached, BYTE, pAddr, vAddr, DATA)<br>byte <- vAddr1..0 xor BigEndianCPU2<br>GPR[rt] <- sign_extend(memword7+8*byte..8*byte)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor ReverseEndian3)<br>memdouble <- LoadMemory (uncached, BYTE, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor BigEndianCPU3<br>GPR[rt] <- sign_extend(memdouble7+8*byte..8*byte)", exceptions: "TLB Refill, TLB Invalid<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "LBU", name: "Load Byte Unsigned", architecture: "MIPS I", bits: [[31, 26, "LBU", "100100"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LBU rt, offset(base) [I-type]", purpose: "To load a byte from memory as an unsigned value.", description: "rt <- memory[base+offset]<br>The contents of the 8-bit byte at the memory location specified by the effective address are fetched, zero-extended, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "None.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE - 1 .. 2 || (pAddr1..0 xor ReverseEndian2)<br>memword <- LoadMemory (uncached, BYTE, pAddr, vAddr, DATA)<br>byte <- vAddr1..0 xor BigEndianCPU2<br>GPR[rt] <- zero_extend(memword7+8* byte..8* byte)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor ReverseEndian3)<br>memdouble <- LoadMemory (uncached, BYTE, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor BigEndianCPU3<br>GPR[rt] <- zero_extend(memdouble7+8* byte..8* byte)", exceptions: "TLB Refill, TLB Invalid<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "LD", name: "Load Doubleword", architecture: "MIPS III", bits: [[31, 26, "LD", "110111"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LD rt, offset(base) [I-type]", purpose: "To load a doubleword from memory.", description: "rt <- memory[base+offset]<br>The contents of the 64-bit doubleword at the memory location specified by the aligned effective address are fetched and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If any of the three least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>GPR[rt] <- memdouble", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "LDC1", name: "Load Doubleword to Coprocessor", architecture: "MIPS II", bits: [[31, 26, "LDC1", "110101"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LDC1 rt, offset(base) [I-type]", purpose: "To load a doubleword from memory to a coprocessor general register.", description: "rt <- memory[base+offset].<br>The contents of the 64-bit doubleword at the memory location specified by the aligned effective address are fetched and made available to coprocessor unit 1. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The manner in which each coprocessor uses the data is defined by the individual coprocessor specifications. The usual operation would place the data into coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If any of the three least-significant bits of the effective address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>COP_LD (1, rt, memdouble)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>COP_LD (1, rt, memdouble)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "LDC2", name: "Load Doubleword to Coprocessor", architecture: "MIPS II", bits: [[31, 26, "LDC2", "110110"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LDC2 rt, offset(base) [I-type]", purpose: "To load a doubleword from memory to a coprocessor general register.", description: "rt <- memory[base+offset].<br>The contents of the 64-bit doubleword at the memory location specified by the aligned effective address are fetched and made available to coprocessor unit 2. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The manner in which each coprocessor uses the data is defined by the individual coprocessor specifications. The usual operation would place the data into coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If any of the three least-significant bits of the effective address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>COP_LD (2, rt, memdouble)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>COP_LD (2, rt, memdouble)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "LDL", name: "Load Doubleword Left", architecture: "MIPS III", bits: [[31, 26, "LDL", "011010"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LDL rt, offset(base) [I-type]", purpose: "To load the most-significant part of a doubleword from an unaligned memory address.", description: "rt <- rt MERGE memory[base+offset]<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the most-significant of eight consecutive bytes forming a doubleword in memory (DW) starting at an arbitrary byte boundary. A part of DW, the most-significant one to eight bytes, is in the aligned doubleword containing EffAddr. This part of DW is loaded appropriately into the most-significant (left) part of GPR rt leaving the remainder of GPR rt unchanged.<br>The figure below illustrates this operation for big-endian byte ordering. The eight consecutive bytes in 2..9 form an unaligned doubleword starting at location 2. A part of DW, six bytes, is contained in the aligned doubleword containing the most-significant byte at 2. First, LDL loads these six bytes into the left part of the destination register and leaves the remainder of the destination unchanged. Next, the complementary LDR loads the remainder of the unaligned doubleword.<br><figure><br><img src=\"images/ldl1.png\" alt=\"Unaligned Doubleword Load using LDL and LDR\" width=\"600\"><br><figcaption>Unaligned Doubleword Load using LDL and LDR.</figcaption><br></figure><br>The bytes loaded from memory to the destination register depend on both the offset of the effective address within an aligned doubleword, i.e. the low three bits of the address (vAddr2..0), and the current byte ordering mode of the processor (big- or little- endian). The table below shows the bytes loaded for every combination of offset and byte ordering.<br><figure><br><img src=\"images/ldl2.png\" alt=\"Bytes Loaded by LDL Instruction\" width=\"600\"><br><figcaption>Bytes Loaded by LDL Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>if BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- vAddr2..0 xor BigEndianCPU3<br>memdouble <- LoadMemory (uncached, byte, pAddr, vAddr, DATA)<br>GPR[rt] <- memdouble7+8*byte..0 || GPR[rt]55-8*byte..0", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "LDR", name: "Load Doubleword Right", architecture: "MIPS III", bits: [[31, 26, "LDR", "011011"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LDR rt, offset(base) [I-type]", purpose: "To load the least-significant part of a doubleword from an unaligned memory address.", description: "rt <- rt MERGE memory[base+offset]<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the least-significant of eight consecutive bytes forming a doubleword in memory (DW) starting at an arbitrary byte boundary. A part of DW, the least-significant one to eight bytes, is in the aligned doubleword containing EffAddr. This part of DW is loaded appropriately into the least-significant (right) part of GPR rt leaving the remainder of GPR rt unchanged.<br>The figure below illustrates this operation for big-endian byte ordering. The eight consecutive bytes in 2..9 form an unaligned doubleword starting at location 2. A part of DW, two bytes, is contained in the aligned doubleword containing the least-significant byte at 9. First, LDR loads these two bytes into the right part of the destination register and leaves the remainder of the destination unchanged. Next, the complementary LDL loads the remainder of the unaligned doubleword.<br><figure><br><img src=\"images/ldr1.png\" alt=\"Unaligned Doubleword Load using LDR and LDL\" width=\"600\"><br><figcaption>Unaligned Doubleword Load using LDR and LDL.</figcaption><br></figure><br>The bytes loaded from memory to the destination register depend on both the offset of the effective address within an aligned doubleword, i.e. the low three bits of the address (vAddr2..0), and the current byte ordering mode of the processor (big- or little- endian). The table below shows the bytes loaded for every combination of offset and byte ordering.<br><figure><br><img src=\"images/ldr2.png\" alt=\"Bytes Loaded by LDR Instruction\" width=\"600\"><br><figcaption>Bytes Loaded by LDR Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>if BigEndianMem = 1 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- vAddr2..0 xor BigEndianCPU3<br>memdouble <- LoadMemory (uncached, byte, pAddr, vAddr, DATA)<br>GPR[rt] <- GPR[rt]63..64-8*byte || memdouble63..8*byte", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "LH", name: "Load Halfword", architecture: "MIPS I", bits: [[31, 26, "LH", "100001"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LH rt, offset(base) [I-type]", purpose: "To load a halfword from memory as a signed value.", description: "rt <- memory[base+offset].<br>The contents of the 16-bit halfword at the memory location specified by the aligned effective address are fetched, sign-extended, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If the least-significant bit of the address is non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order bit of the offset field must be zero. If it is not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE - 1..2 || (pAddr1..0 xor (ReverseEndian || 0))<br>memword <- LoadMemory (uncached, HALFWORD, pAddr, vAddr, DATA)<br>byte <- vAddr1..0 xor (BigEndianCPU || 0)<br>GPR[rt] <- sign_extend(memword15+8*byte..8* byte)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE - 1..3 || (pAddr2..0 xor (ReverseEndian || 0))<br>memdouble <- LoadMemory (uncached, HALFWORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU2 || 0)<br>GPR[rt] <- sign_extend(memdouble15+8*byte..8* byte)", exceptions: "TLB Refill , TLB Invalid<br>Bus Error<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "LHU", name: "Load Halfword Unsigned", architecture: "MIPS I", bits: [[31, 26, "LHU", "100101"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LHU rt, offset(base) [I-type]", purpose: "To load a halfword from memory as an unsigned value.", description: "rt <- memory[base+offset]<br>The contents of the 16-bit halfword at the memory location specified by the aligned effective address are fetched, zero-extended, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If the least-significant bit of the address is non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order bit of the offset field must be zero. If it is not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE - 1..2 || (pAddr1..0 xor (ReverseEndian || 0))<br>memword <- LoadMemory (uncached, HALFWORD, pAddr, vAddr, DATA)<br>byte <- vAddr1..0 xor (BigEndianCPU || 0)<br>GPR[rt] <- zero_extend(memword15+8*byte..8*byte)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE - 1..3 || (pAddr2..0 xor (ReverseEndian2 || 0))<br>memdouble <- LoadMemory (uncached, HALFWORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU2 || 0)<br>GPR[rt] <- zero_extend(memdouble15+8*byte..8*byte)", exceptions: "TLB Refill, TLB Invalid<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "LL", name: "Load Linked Word", architecture: "MIPS II", bits: [[31, 26, "LL", "110000"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LL rt, offset(base) [I-type]", purpose: "To load a word from memory for an atomic read-modify-write.", description: "rt <- memory[base+offset]<br>The LL and SC instructions provide primitives to implement atomic Read-Modify-Write (RMW) operations for cached memory locations.<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address.<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched, sign-extended to the GPR register length if necessary, and written into GPR rt. This begins a RMW sequence on the current processor.<br>There is one active RMW sequence per processor. When an LL is executed it starts the active RMW sequence replacing any other sequence that was active.<br>The RMW sequence is completed by a subsequent SC instruction that either completes the RMW sequence atomically and succeeds, or does not and fails. See the description of SC for a list of events and conditions that cause the SC to fail and an example instruction sequence using LL and SC.<br>Executing LL on one processor does not cause an action that, by itself, would cause an SC for the same block to fail on another processor.<br>An execution of LL does not have to be followed by execution of SC; a program is free to abandon the RMW sequence without attempting a write.", restrictions: "The addressed location must be cached; if it is not, the result is undefined.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the effective address are non-zero an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memword <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>GPR[rt] <- memword<br>LLbit <- 1<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>GPR[rt] <- sign_extend(memdouble31+8*byte..8*byte)<br>LLbit <- 1", exceptions: "TLB Refill, TLB Invalid<br>Address Error<br>Reserved Instruction", programming_notes: "There is no Load Linked Word Unsigned operation corresponding to Load Word Unsigned.", implementation_notes: "An LL on one processor must not take action that, by itself, would cause an SC for the same block on another processor to fail. If an implementation depends on retaining the data in cache during the RMW sequence, cache misses caused by LL must not fetch data in the exclusive state, thus removing it from the cache, if it is present in another cache."},
{symbol: "LLD", name: "Load Linked Doubleword", architecture: "MIPS III", bits: [[31, 26, "LLD", "110100"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LLD rt, offset(base) [I-type]", purpose: "To load a doubleword from memory for an atomic read-modify-write.", description: "rt <- memory[base+offset]<br>The LLD and SCD instructions provide primitives to implement atomic Read-Modify-Write (RMW) operations for cached memory locations.<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address.<br>The contents of the 64-bit doubleword at the memory location specified by the aligned effective address are fetched and written into GPR rt. This begins a RMW sequence on the current processor.<br>There is one active RMW sequence per processor. When an LLD is executed it starts the active RMW sequence replacing any other sequence that was active.<br>The RMW sequence is completed by a subsequent SCD instruction that either completes the RMW sequence atomically and succeeds, or does not and fails. See the description of SCD for a list of events and conditions that cause the SCD to fail and an example instruction sequence using LLD and SCD.<br>Executing LLD on one processor does not cause an action that, by itself, would cause an SCD for the same block to fail on another processor.<br>An execution of LLD does not have to be followed by execution of SCD; a program is free to abandon the RMW sequence without attempting a write.", restrictions: "The addressed location must be cached; if it is not, the result is undefined.<br>The effective address must be naturally aligned. If either of the three least-significant bits of the effective address are non-zero an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>GPR[rt] <- memdouble<br>LLbit <- 1", exceptions: "TLB Refill, TLB Invalid<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: "An LLD on one processor must not take action that, by itself, would cause an SCD for the same block on another processor to fail. If an implementation depends on retaining the data in cache during the RMW sequence, cache misses caused by LLD must not fetch data in the exclusive state, thus removing it from the cache, if it is present in another cache."},
{symbol: "LUI", name: "Load Upper Immediate", architecture: "MIPS I", bits: [[31, 26, "LUI", "001111"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "LUI rt, immediate [I-type]", purpose: "To load a constant into the upper half of a word.", description: "rt <- immediate || 016.<br>The 16-bit immediate is shifted left 16 bits and concatenated with 16 bits of low-order zeros. The 32-bit result is sign-extended and placed into GPR rt.", restrictions: "None.", operation: "GPR[rt] <- sign_extend(immediate || 016)", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "LW", name: "Load Word", architecture: "MIPS I", bits: [[31, 26, "LW", "100011"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LW rt, offset(base) [I-type]", purpose: "To load a word from memory as a signed value.", description: "rt <- memory[base+offset]<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched, sign-extended to the GPR register length if necessary, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>memword <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>GPR[rt] <- memword<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>GPR[rt] <- sign_extend(memdouble31+8*byte..8*byte)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "LWC1", name: "Load Word To Coprocessor", architecture: "MIPS I", bits: [[31, 26, "LWC1", "110001"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWC1 rt, offset(base) [I-type]", purpose: "To load a word from memory to a coprocessor general register.", description: "rt <- memory[base+offset]<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched and made available to coprocessor unit 1. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The manner in which each coprocessor uses the data is defined by the individual coprocessor specification. The usual operation would place the data into coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>I:<br>&emsp;vAddr <- sign_extend(offset) + GPR[base]<br>&emsp;if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>&emsp;(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>&emsp;memword <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>I+1:<br>&emsp;COP_LW (1, rt, memword)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base}<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>memword <- memdouble31+8*byte..8*byte<br>COP_LW (1, rt, memdouble)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "LWC2", name: "Load Word To Coprocessor", architecture: "MIPS I", bits: [[31, 26, "LWC2", "110010"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWC2 rt, offset(base) [I-type]", purpose: "To load a word from memory to a coprocessor general register.", description: "rt <- memory[base+offset]<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched and made available to coprocessor unit 2. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The manner in which each coprocessor uses the data is defined by the individual coprocessor specification. The usual operation would place the data into coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>I:<br>&emsp;vAddr <- sign_extend(offset) + GPR[base]<br>&emsp;if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>&emsp;(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>&emsp;memword <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>I+1:<br>&emsp;COP_LW (2, rt, memword)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base}<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>memword <- memdouble31+8*byte..8*byte<br>COP_LW (2, rt, memdouble)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "LWC3", name: "Load Word To Coprocessor", architecture: "MIPS I", bits: [[31, 26, "LWC3", "110011"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWC3 rt, offset(base) [I-type]", purpose: "To load a word from memory to a coprocessor general register.", description: "rt <- memory[base+offset]<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched and made available to coprocessor unit 3. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The manner in which each coprocessor uses the data is defined by the individual coprocessor specification. The usual operation would place the data into coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>I:<br>&emsp;vAddr <- sign_extend(offset) + GPR[base]<br>&emsp;if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>&emsp;(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>&emsp;memword <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>I+1:<br>&emsp;COP_LW (3, rt, memword)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base}<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, DOUBLEWORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>memword <- memdouble31+8*byte..8*byte<br>COP_LW (3, rt, memdouble)", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "LWL", name: "Load Word Left", architecture: "MIPS I", bits: [[31, 26, "LWL", "100010"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWL rt, offset(base) [I-type]", purpose: "To load the most-significant part of a word as a signed value from an unaligned memory address.", description: "rt <- rt MERGE memory[base+offset]<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the most-significant of four consecutive bytes forming a word in memory (W) starting at an arbitrary byte boundary. A part of W, the most-significant one to four bytes, is in the aligned word containing EffAddr. This part of W is loaded into the most-significant (left) part of the word in GPR rt. The remaining least-significant part of the word in GPR rt is unchanged.<br>If GPR rt is a 64-bit register, the destination word is the low-order word of the register. The loaded value is treated as a signed value; the word sign bit (bit 31) is always loaded from memory and the new sign bit value is copied into bits 63..32.<br><figure><br><img src=\"images/lwl1.png\" alt=\"Unaligned Word Load using LWL and LWR\" width=\"600\"><br><figcaption>Unaligned Word Load using LWL and LWR.</figcaption><br></figure><br>The figure above illustrates this operation for big-endian byte ordering for 32-bit and 64-bit registers. The four consecutive bytes in 2..5 form an unaligned word starting at location 2. A part of W, two bytes, is in the aligned word containing the most-significant byte at 2. First, LWL loads these two bytes into the left part of the destination register word and leaves the right part of the destination word unchanged. Next, the complementary LWR loads the remainder of the unaligned word.<br>The bytes loaded from memory to the destination register depend on both the offset of the effective address within an aligned word, i.e. the low two bits of the address (vAddr1..0), and the current byte ordering mode of the processor (big- or little-endian). The table below shows the bytes loaded for every combination of offset and byte ordering.<br><figure><br><img src=\"images/lwl2.png\" alt=\"Bytes Loaded by LWL Instruction\" width=\"600\"><br><figcaption>Bytes Loaded by LWL Instruction.</figcaption><br></figure><br>The unaligned loads, LWL and LWR, are exceptions to the load-delay scheduling restriction in the MIPS I architecture. An unaligned load instruction to GPR rt that immediately follows another load to GPR rt can \"read\" the loaded data. It will correctly merge the 1 to 4 loaded bytes with the data loaded by the previous instruction.", restrictions: "MIPS I scheduling restriction: The loaded data is not available for use by the following instruction. The instruction immediately following this one, unless it is an unaligned load (LWL, LWR), may not use GPR rt as a source register. If this restriction is violated, the result of the operation is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..2 || (pAddr1..0 xor ReverseEndian2)<br>if BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>memword <- LoadMemory (uncached, byte, pAddr, vAddr, DATA)<br>GPR[rt] <- memword7+8*byte..0 || GPR[rt]23-8*byte..0<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>if BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- 0 || (vAddr1..0 xor BigEndianCPU2)<br>word <- vAddr2 xor BigEndianCPU<br>memdouble <- LoadMemory (uncached, byte, pAddr, vAddr, DATA)<br>temp <- memdouble31+32*word-8*byte..32*word || GPR[rt]23-8*byte..0<br>GPR[rt] <- (temp31)32 || temp", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error", programming_notes: "The architecture provides no direct support for treating unaligned words as unsigned values, i.e. zeroing bits 63..32 of the destination register when bit 31 is loaded. See SLL or SLLV for a single-instruction method of propagating the word sign bit in a register into the upper half of a 64-bit register.", implementation_notes: ""},
{symbol: "LWR", name: "Load Word Right", architecture: "MIPS I", bits: [[31, 26, "LWR", "100110"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWR rt, offset(base) [I-type]", purpose: "", description: "rt <- rt MERGE memory[base+offset]<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the least-significant of four consecutive bytes forming a word in memory (W) starting at an arbitrary byte boundary. A part of W, the least-significant one to four bytes, is in the aligned word containing EffAddr. This part of W is loaded into the least-significant (right) part of the word in GPR rt. The remaining most-significant part of the word in GPR rt is unchanged.<br>If GPR rt is a 64-bit register, the destination word is the low-order word of the register. The loaded value is treated as a signed value; if the word sign bit (bit 31) is loaded (i.e. when all four bytes are loaded) then the new sign bit value is copied into bits 63..32. If bit 31 is not loaded then the value of bits 63..32 is implementation dependent; the value is either unchanged or a copy of the current value of bit 31. Executing both LWR and LWL, in either order, delivers in a sign-extended word value in the destination register.<br><figure><br><img src=\"images/lwr1.png\" alt=\"Unaligned Word Load using LWR and LWL\" width=\"600\"><br><figcaption>Unaligned Word Load using LWR and LWL.</figcaption><br></figure><br>The figure above illustrates this operation for big-endian byte ordering for 32-bit and 64-bit registers. The four consecutive bytes in 2..5 form an unaligned word starting at location 2. A part of W, two bytes, is in the aligned word containing the least-significant byte at 5. First, LWR loads these two bytes into the right part of the destination register. Next, the complementary LWL loads the remainder of the unaligned word.<br>The bytes loaded from memory to the destination register depend on both the offset of the effective address within an aligned word, i.e. the low two bits of the address (vAddr1..0), and the current byte ordering mode of the processor (big- or little-endian). The table below shows the bytes loaded for every combination of offset and byte ordering.<br><figure><br><img src=\"images/lwr2.png\" alt=\"Bytes Loaded by LWR Instruction\" width=\"600\"><br><figcaption>Bytes Loaded by LWR Instruction.</figcaption><br></figure><br>The unaligned loads, LWL and LWR, are exceptions to the load-delay scheduling restriction in the MIPS I architecture. An unaligned load to GPR rt that immediately follows another load to GPR rt can \"read\" the loaded data. It will correctly merge the 1 to 4 loaded bytes with the data loaded by the previous instruction.", restrictions: "MIPS I scheduling restriction: The loaded data is not available for use by the following instruction. The instruction immediately following this one, unless it is an unaligned load (LWL, LWR), may not use GPR rt as a source register. If this restriction is violated, the result of the operation is undefined.<br>None.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..2 || (pAddr1..0 xor ReverseEndian2)<br>if BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>memword <- LoadMemory (uncached, byte, pAddr, vAddr, DATA)<br>GPR[rt] <- memword31..32-8*byte || GPR[rt]31-8*byte..0<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>if BigEndianMem = 1 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>word <- vAddr2 xor BigEndianCPU<br>memdouble <- LoadMemory (uncached, 0 || byte, pAddr, vAddr, DATA)<br>temp <- GPR[rt]31..32-8*byte || memdouble31+32*word..32*word+8*byte<br>if byte = 4 then<br>&emsp;utemp <- (temp31)32&emsp;/* loaded bit 31, must sign extend */<br>else<br>&emsp;one of the following two behaviors:<br>&emsp;&emsp;utemp <- GPR[rt]63..32&emsp;/* leave what was there alone */<br>&emsp;&emsp;utemp <- (GPR[rt]31)32&emsp;/* sign-extend bit 31 */<br>endif<br>GPR[rt] <- utemp || temp", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error", programming_notes: "The architecture provides no direct support for treating unaligned words as unsigned values, i.e. zeroing bits 63..32 of the destination register when bit 31 is loaded. See SLL or SLLV for a single-instruction method of propagating the word sign bit in a register into the upper half of a 64-bit register.", implementation_notes: ""},
{symbol: "LWU", name: "Load Word Unsigned", architecture: "MIPS III", bits: [[31, 26, "LWU", "100111"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "LWU rt, offset(base) [I-type]", purpose: "To load a word from memory as an unsigned value.", description: "rt <- memory[base+offset]<br>The contents of the 32-bit word at the memory location specified by the aligned effective address are fetched, zero-extended, and placed in GPR rt. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, LOAD)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>memdouble <- LoadMemory (uncached, WORD, pAddr, vAddr, DATA)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>GPR[rt] <- 032 || memdouble31+8*byte..8*byte", exceptions: "TLB Refill, TLB Invalid<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "MFHI", name: "Move From HI Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 16, "0", "0000000000"],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "MFHI", "010000"]], format: "MFHI rd [R-type]", purpose: "To copy the special purpose HI register to a GPR.", description: "rd <- HI<br>The contents of special register HI are loaded into GPR rd.", restrictions: "The two instructions that follow an MFHI instruction must not be instructions that modify the HI register: DDIV, DDIVU, DIV, DIVU, DMULT, DMULTU, MTHI, MULT, MULTU. If this restriction is violated, the result of the MFHI is undefined.", operation: "GPR[rd] <- HI", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "MFLO", name: "Move From LO Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 16, "0", "0000000000"],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "MFLO", "010010"]], format: "MFLO rd [R-type]", purpose: "To copy the special purpose LO register to a GPR.", description: "rd <- LO<br>The contents of special register LO are loaded into GPR rd.", restrictions: "The two instructions that follow an MFLO instruction must not be instructions that modify the LO register: DDIV, DDIVU, DIV, DIVU, DMULT, DMULTU, MTLO, MULT, MULTU. If this restriction is violated, the result of the MFLO is undefined.", operation: "GPR[rd] <- LO", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "MOVN", name: "Move Conditional on Not Zero", architecture: "MIPS IV", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "MOVN", "001011"]], format: "MOVN rd, rs, rt [R-type]", purpose: "To conditionally move a GPR after testing a GPR value.", description: "if (rt !=  0) then rd <- rs<br>If the value in GPR rt is not equal to zero, then the contents of GPR rs are placed into GPR rd.", restrictions: "None.", operation: "if GPR[rt] !=  0 then<br>&emsp;GPR[rd] <- GPR[rs]<br>endif", exceptions: "Reserved Instruction", programming_notes: "The nonzero value tested here is the \"condition true\" result from the SLT, SLTI, SLTU, and SLTIU comparison instructions.", implementation_notes: ""},
{symbol: "MOVZ", name: "Move Conditional on Zero", architecture: "MIPS IV", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "MOVZ", "001010"]], format: "MOVZ rd, rs, rt [R-type]", purpose: "To conditionally move a GPR after testing a GPR value.", description: "if (rt = 0) then rd <- rs<br>If the value in GPR rt is equal to zero, then the contents of GPR rs are placed into GPR rd.", restrictions: "None.", operation: "if GPR[rt] = 0 then<br>&emsp;GPR[rd] <- GPR[rs]<br>endif", exceptions: "Reserved Instruction", programming_notes: "The zero value tested here is the \"condition false\" result from the SLT, SLTI, SLTU, and SLTIU comparison instructions.", implementation_notes: ""},
{symbol: "MTHI", name: "Move To HI Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 6, "0", "000000000000000"],[5, 0, "MTHI", "010001"]], format: "MTHI rs [R-type]", purpose: "To copy a GPR to the special purpose HI register.", description: "HI <- rs<br>The contents of GPR rs are loaded into special register HI.", restrictions: "If either of the two preceding instructions is MFHI, the result of that MFHI is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.<br>A computed result written to the HI/LO pair by DDIV, DDIVU, DIV, DIVU, DMULT, DMULTU, MULT, or MULTU must be read by MFHI or MFLO before another result is written into either HI or LO. If an MTHI instruction is executed following one of these arithmetic instructions, but before a MFLO or MFHI instruction, the contents of LO are undefined. The following example shows this illegal situation:<br>MUL r2, r4	# start operation that will eventually write to HI,LO<br>...	# code not containing mfhi or mflo<br>MTHI r6<br>...	# code not containing mflo<br>MFLO r3	# this mflo would get an undefined value", operation: "I-2:, I-1:<br>&emsp;HI <- undefined<br>I:<br>&emsp;HI <- GPR[rs]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "MTLO", name: "Move To LO Register", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 6, "0", "000000000000000"],[5, 0, "MTLO", "010011"]], format: "MTLO rs [R-type]", purpose: "To copy a GPR to the special purpose LO register.", description: "LO <- rs<br>The contents of GPR rs are loaded into special register LO.", restrictions: "If either of the two preceding instructions is MFLO, the result of that MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.<br>A computed result written to the HI/LO pair by DDIV, DDIVU, DIV, DIVU, DMULT, DMULTU, MULT, or MULTU must be read by MFHI or MFLO before another result is written into either HI or LO. If an MTLO instruction is executed following one of these arithmetic instructions, but before a MFLO or MFHI instruction, the contents of HI are undefined. The following example shows this illegal situation:<br>MUL r2, r4	# start operation that will eventually write to HI,LO<br>...	# code not containing mfhi or mflo<br>MTLO r6<br>...	# code not containing mfhi<br>MFHI r3	# this mfhi would get an undefined value", operation: "I-2:, I-1:<br>&emsp;LO <- undefined<br>I:<br>&emsp;LO <- GPR[rs]", exceptions: "None", programming_notes: "", implementation_notes: ""},
{symbol: "MULT", name: "Multiply Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "MULT", "011000"]], format: "MULT rs, rt [R-type]", purpose: "To multiply 32-bit signed integers.", description: "(LO, HI) <- rs * rt<br>The 32-bit word value in GPR rt is multiplied by the 32-bit value in GPR rs, treating both operands as signed values, to produce a 64-bit result. The low-order 32-bit word of the result is placed into special register LO, and the high-order 32-bit word is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.<br>If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined<br>I:<br>&emsp;prod <- GPR[rs]31..0 * GPR[rt]31..0<br>&emsp;LO <- sign_extend(prod31..0)<br>&emsp;HI <- sign_extend(prod63..32)", exceptions: "None.", programming_notes: "In some processors the integer multiply operation may proceed asynchronously and allow other CPU instructions to execute before it is complete. An attempt to read LO or HI before the results are written will wait (interlock) until the results are ready. Asynchronous execution does not affect the program result, but offers an opportunity for performance improvement by scheduling the multiply so that other instructions can execute in parallel.<br>Programs that require overflow detection must check for it explicitly.", implementation_notes: ""},
{symbol: "MULTU", name: "Multiply Unsigned Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "0", "0000000000"],[5, 0, "MULTU", "011001"]], format: "MULTU rs, rt [R-type]", purpose: "To multiply 32-bit unsigned integers.", description: "(LO, HI) <- rs * rt<br>The 32-bit word value in GPR rt is multiplied by the 32-bit value in GPR rs, treating both operands as unsigned values, to produce a 64-bit result. The low-order 32-bit word of the result is placed into special register LO, and the high-order 32-bit word is placed into special register HI.<br>No arithmetic exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.<br>If either of the two preceding instructions is MFHI or MFLO, the result of the MFHI or MFLO is undefined. Reads of the HI or LO special registers must be separated from subsequent instructions that write to them by two or more other instructions.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>I-2:, I-1:<br>&emsp;LO, HI <- undefined<br>I:<br>&emsp;prod <- (0 || GPR[rs]31..0) * (0 || GPR[rt]31..0)<br>&emsp;LO <- sign_extend(prod31..0)<br>&emsp;HI <- sign_extend(prod63..32)", exceptions: "None.", programming_notes: "In some processors the integer multiply operation may proceed asynchronously and allow other CPU instructions to execute before it is complete. An attempt to read LO or HI before the results are written will wait (interlock) until the results are ready. Asynchronous execution does not affect the program result, but offers an opportunity for performance improvement by scheduling the multiply so that other instructions can execute in parallel.<br>Programs that require overflow detection must check for it explicitly.", implementation_notes: ""},
{symbol: "NOR", name: "Not Or", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "NOR", "100111"]], format: "NOR rd, rs, rt [R-type]", purpose: "To do a bitwise logical NOT OR.", description: "rd <- rs NOR rt<br>The contents of GPR rs are combined with the contents of GPR rt in a bitwise logical NOR operation. The result is placed into GPR rd.", restrictions: "None.", operation: "GPR[rd] <- GPR[rs] nor GPR[rt]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "OR", name: "Or", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "OR", "100101"]], format: "OR rd, rs, rt [R-type]", purpose: "To do a bitwise logical OR.", description: "rd <- rs OR rt<br>The contents of GPR rs are combined with the contents of GPR rt in a bitwise logical OR operation. The result is placed into GPR rd.", restrictions: "None.", operation: "GPR[rd] <- GPR[rs] or GPR[rt]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "ORI", name: "Or Immediate", architecture: "MIPS I", bits: [[31, 26, "ORI", "001101"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "ORI rt, rs, immediate [I-type]", purpose: "To do a bitwise logical OR with a constant.", description: "rd <- rs OR immediate<br>The 16-bit immediate is zero-extended to the left and combined with the contents of GPR rs in a bitwise logical OR operation. The result is placed into GPR rt.", restrictions: "None.", operation: "GPR[rt] <- zero_extend(immediate) or GPR[rs]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "PREF", name: "Prefetch", architecture: "MIPS IV", bits: [[31, 26, "PREF", "110011"],[25, 21, "base", ""],[20, 16, "hint", ""],[15, 0, "offset", ""]], format: "PREF hint, offset(base) [I-type]", purpose: "To prefetch data from memory.", description: "prefetch_memory(base+offset)<br>PREF adds the 16-bit signed offset to the contents of GPR base to form an effective byte address. It advises that data at the effective address may be used in the near future. The hint field supplies information about the way that the data is expected to be used.<br>PREF is an advisory instruction. It may change the performance of the program. For all hint values and all effective addresses, it neither changes architecturally-visible state nor alters the meaning of the program. An implementation may do nothing when executing a PREF instruction.<br>If MIPS IV instructions are supported and enabled, PREF does not cause addressing- related exceptions. If it raises an exception condition, the exception condition is ignored. If an addressing-related exception condition is raised and ignored, no data will be prefetched, Even if no data is prefetched in such a case, some action that is not architecturally-visible, such as writeback of a dirty cache line, might take place.<br>PREF will never generate a memory operation for a location with an uncached memory access type.<br>If PREF results in a memory operation, the memory access type used for the operation is determined by the memory access type of the effective address, just as it would be if the memory operation had been caused by a load or store to the effective address.<br>PREF enables the processor to take some action, typically prefetching the data into cache, to improve program performance. The action taken for a specific PREF instruction is both system and context dependent. Any action, including doing nothing, is permitted that does not change architecturally-visible state or alter the meaning of a program. It is expected that implementations will either do nothing or take an action that will increase the performance of the program.<br>For a cached location, the expected, and useful, action is for the processor to prefetch a block of data that includes the effective address. The size of the block, and the level of the memory hierarchy it is fetched into are implementation specific.<br>The hint field supplies information about the way the data is expected to be used. No hint value causes an action that modifies architecturally-visible state. A processor may use a hint value to improve the effectiveness of the prefetch action. The defined hint values and the recommended prefetch action are shown in the table below. The hint table may be extended in future implementations.<br><figure><br><img src=\"images/pref1.png\" alt=\"Values of Hint Field for Prefetch Instruction\" width=\"600\"><br><figcaption>Values of Hint Field for Prefetch Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "vAddr <- GPR[base] + sign_extend(offset)<br>(pAddr, uncached) <- AddressTranslation(vAddr, DATA, LOAD)<br>Prefetch(uncached, pAddr, vAddr, DATA, hint)", exceptions: "Reserved Instruction", programming_notes: "Prefetch can not prefetch data from a mapped location unless the translation for that location is present in the TLB. Locations in memory pages that have not been accessed recently may not have translations in the TLB, so prefetch may not be effective for such locations.<br>Prefetch does not cause addressing exceptions. It will not cause an exception to prefetch using an address pointer value before the validity of a pointer is determined.", implementation_notes: "It is recommended that a reserved hint field value either cause a default prefetch action that is expected to be useful for most cases of data use, such as the \"load\" hint, or cause the instruction to be treated as a NOP."},
{symbol: "SB", name: "Store Byte", architecture: "MIPS I", bits: [[31, 26, "SB", "101000"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SB rt, offset(base) [I-type]", purpose: "To store a byte to memory.", description: "memory[base+offset] <- rt<br>The least-significant 8-bit byte of GPR rt is stored in memory at the location specified by the effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "None.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..2 || (pAddr1..0 xor ReverseEndian2)<br>byte <- vAddr1..0 xor BigEndianCPU2<br>dataword <- GPR[rt]31-8*byte..0 || 08*byte<br>StoreMemory (uncached, BYTE, dataword, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor ReverseEndian3)<br>byte <- vAddr2..0 xor BigEndianCPU3<br>datadouble <- GPR[rt]63-8*byte..0 || 08*byte<br>StoreMemory (uncached, BYTE, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Bus Error<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "SC", name: "Store Conditional Word", architecture: "MIPS II", bits: [[31, 26, "SC", "111000"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SC rt, offset(base) [I-type]", purpose: "To store a word to memory to complete an atomic read-modify-write.", description: "if (atomic_update) then memory[base+offset] <- rt, rt <- 1 else rt <- 0<br>The LL and SC instructions provide primitives to implement atomic Read-Modify-Write (RMW) operations for cached memory locations.<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address.<br>The SC completes the RMW sequence begun by the preceding LL instruction executed on the processor. If it would complete the RMW sequence atomically, then the least- significant 32-bit word of GPR rt is stored into memory at the location specified by the aligned effective address and a one, indicating success, is written into GPR rt. Otherwise, memory is not modified and a zero, indicating failure, is written into GPR rt.<br>If any of the following events occurs between the execution of LL and SC, the SC will fail:<br>-	A coherent store is completed by another processor or coherent I/O module into the block of physical memory containing the word. The size and alignment of the block is implementation dependent. It is at least one word and is at most the minimum page size.<br>-	An exception occurs on the processor executing the LL/SC. An implementation may detect \"an exception\" in one of three ways:<br>	1) Detect exceptions and fail when an exception occurs.<br>	2) Fail after the return-from-interrupt instruction (RFE or ERET) is executed.<br>	3) Do both 1 and 2.<br>If any of the following events occurs between the execution of LL and SC, the SC may succeed or it may fail; the success or failure is unpredictable. Portable programs should not cause one of these events.<br>-	A load, store, or prefetch is executed on the processor executing the LL/SC.<br>-	The instructions executed starting with the LL and ending with the SC do not lie in a 2048-byte contiguous region of virtual memory. The region does not have to be aligned, other than the alignment required for instruction words.<br>The following conditions must be true or the result of the SC will be undefined:<br>-	Execution of SC must have been preceded by execution of an LL instruction.<br>-	A RMW sequence executed without intervening exceptions must use the same address in the LL and SC. The address is the same if the virtual address, physical address, and cache-coherence algorithm are identical.<br>Atomic RMW is provided only for cached memory locations. The extent to which the detection of atomicity operates correctly depends on the system implementation and the memory access type used for the location.<br>MP atomicity: To provide atomic RMW among multiple processors, all accesses to the location must be made with a memory access type of cached coherent.<br>Uniprocessor atomicity: To provide atomic RMW on a single processor, all accesses to the location must be made with memory access type of either cached noncoherent or cached coherent. All accesses must be to one or the other access type, they may not be mixed.<br>I/O System: To provide atomic RMW with a coherent I/O system, all accesses to the location must be made with a memory access type of cached coherent. If the I/O system does not use coherent memory operations, then atomic RMW cannot be provided with respect to the I/O reads and writes.<br>The definition above applies to user-mode operation on all MIPS processors that support the MIPS II architecture. There may be other implementation-specific events, such as privileged CP0 instructions, that will cause an SC instruction to fail in some cases. System programmers using LL/SC should consult implementation-specific documentation.", restrictions: "The addressed location must have a memory access type of cached noncoherent or cached coherent; if it does not, the result is undefined.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>dataword <- GPR[rt]<br>if LLbit then<br>&emsp;StoreMemory (uncached, WORD, dataword, pAddr, vAddr, DATA)<br>endif<br>GPR[rt] <- 031 || LLbit<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>datadouble <- GPR[rt]63-8*byte..0 || 08*byte<br>if LLbit then<br>&emsp;StoreMemory (uncached, WORD, datadouble, pAddr, vAddr, DATA)<br>endif<br>GPR[rt] <- 063 || LLbit", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction", programming_notes: "LL and SC are used to atomically update memory locations as shown in the example atomic increment operation below.<br>L1:<br>	LL	T1, (T0)	# load counter<br>	ADDI	T2, T1, 1	# increment<br>	SC	T2, (T0)	# try to store, checking for atomicity<br>	BEQ	T2, 0, L1	# if not atomic (0), try again<br>	NOP	# branch-delay slot<br>Exceptions between the LL and SC cause SC to fail, so persistent exceptions must be avoided. Some examples of these are arithmetic operations that trap, system calls, floating-point operations that trap or require software emulation assistance.<br>LL and SC function on a single processor for cached noncoherent memory so that parallel programs can be run on uniprocessor systems that do not support cached coherent memory access types.", implementation_notes: "The block of memory that is \"locked\" for LL/SC is typically the largest cache line in use."},
{symbol: "SCD", name: "Store Conditional Doubleword", architecture: "MIPS III", bits: [[31, 26, "SCD", "111100"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SCD rt, offset(base) [I-type]", purpose: "To store a doubleword to memory to complete an atomic read-modify-write.", description: "if (atomic_update) then memory[base+offset] <- rt, rt <- 1 else rt <- 0<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address.<br>The SCD completes the RMW sequence begun by the preceding LLD instruction executed on the processor. If it would complete the RMW sequence atomically, then the 64-bit doubleword of GPR rt is stored into memory at the location specified by the aligned effective address and a one, indicating success, is written into GPR rt. Otherwise, memory is not modified and a zero, indicating failure, is written into GPR rt.<br>If any of the following events occurs between the execution of LLD and SCD, the SCD will fail:<br>-	A coherent store is completed by another processor or coherent I/O module into the block of physical memory containing the word. The size and alignment of the block is implementation dependent. It is at least one doubleword and is at most the minimum page size.<br>-	An exception occurs on the processor executing the LLD/SCD. An implementation may detect \"an exception\" in one of three ways:<br>	1) Detect exceptions and fail when an exception occurs.<br>	2) Fail after the return-from-interrupt instruction (RFE or ERET) is executed.<br>	3) Do both 1 and 2.<br>If any of the following events occurs between the execution of LLD and SCD, the SCD may succeed or it may fail; the success or failure is unpredictable. Portable programs should not cause one of these events.<br>-	A memory access instruction (load, store, or prefetch) is executed on the processor executing the LLD/SCD.<br>-	The instructions executed starting with the LLD and ending with the SCD do not lie in a 2048-byte contiguous region of virtual memory. The region does not have to be aligned, other than the alignment required for instruction words.<br>The following conditions must be true or the result of the SCD will be undefined:<br>-	Execution of SCD must have been preceded by execution of an LLD instruction.<br>-	A RMW sequence executed without intervening exceptions must use the same address in the LLD and SCD. The address is the same if the virtual address, physical address, and cache-coherence algorithm are identical.<br>Atomic RMW is provided only for memory locations with cached noncoherent or cached coherent memory access types. The extent to which the detection of atomicity operates correctly depends on the system implementation and the memory access type used for the location.<br>MP atomicity: To provide atomic RMW among multiple processors, all accesses to the location must be made with a memory access type of cached coherent.<br>Uniprocessor atomicity: To provide atomic RMW on a single processor, all accesses to the location must be made with memory access type of either cached noncoherent or cached coherent. All accesses must be to one or the other access type, they may not be mixed.<br>I/O System: To provide atomic RMW with a coherent I/O system, all accesses to the location must be made with a memory access type of cached coherent. If the I/O system does not use coherent memory operations, then atomic RMW cannot be provided with respect to the I/O reads and writes.<br>The defemination above applies to user-mode operation on all MIPS processors that support the MIPS III architecture. There may be other implementation-specific events, such as privileged CP0 instructions, that will cause an SCD instruction to fail in some cases. System programmers using LLD/SCD should consult implementation-specific documentation.", restrictions: "The addressed location must have a memory access type of cached noncoherent or cached coherent; if it does not, the result is undefined. The 64-bit doubleword of register rt is conditionally stored in memory at the location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The effective address must be naturally aligned. If any of the three least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- GPR[rt]<br>if LLbit then<br>&emsp;StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)<br>endif<br>GPR[rt] <- 063 || LLbit", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction", programming_notes: "LLD and SCD are used to atomically update memory locations as shown in the example atomic increment operation below.<br>L1:<br>	LLD	T1, (T0)	# load counter<br>	ADDI	T2, T1, 1	# increment<br>	SCD	T2, (T0)	# try to store, checking for atomicity<br>	BEQ	T2, 0, L1	# if not atomic (0), try again<br>	NOP	# branch-delay slot<br>Exceptions between the LLD and SCD cause SCD to fail, so persistent exceptions must be avoided. Some examples of these are arithmetic operations that trap, system calls, floating-point operations that trap or require software emulation assistance.<br>LLD and SCD function on a single processor for cached noncoherent memory so that parallel programs can be run on uniprocessor systems that do not support cached coherent memory access types.", implementation_notes: "The block of memory that is \"locked\" for LLD/SCD is typically the largest cache line in use."},
{symbol: "SD", name: "Store Doubleword", architecture: "MIPS III", bits: [[31, 26, "SD", "111111"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SD rt, offset(base) [I-type]", purpose: "To store a doubleword to memory.", description: "memory[base+offset] <- rt<br>The 64-bit doubleword in GPR rt is stored in memory at the location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If any of the three least-significant bits of the effective address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- GPR[rt]<br>StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "SDC1", name: "Store Doubleword From Coprocessor", architecture: "MIPS II", bits: [[31, 26, "SDC1", "111101"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SDC1 rt, offset(base) [I-type]", purpose: "To store a doubleword from a coprocessor general register to memory.", description: "memory[base+offset] <- rt<br>Coprocessor unit 1 supplies a 64-bit doubleword which is stored at the memory location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The data supplied by each coprocessor is defined by the individual coprocessor specifications. The usual operation would read the data from coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not defined for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If any of the three least-significant bits of the effective address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- COP_SD(1, rt)<br>StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- COP_SD(1, rt)<br>StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "SDC2", name: "Store Doubleword From Coprocessor", architecture: "MIPS II", bits: [[31, 26, "SDC2", "111110"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SDC2 rt, offset(base) [I-type]", purpose: "To store a doubleword from a coprocessor general register to memory.", description: "memory[base+offset] <- rt<br>Coprocessor unit 2 supplies a 64-bit doubleword which is stored at the memory location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The data supplied by each coprocessor is defined by the individual coprocessor specifications. The usual operation would read the data from coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not defined for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If any of the three least-significant bits of the effective address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 3 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- COP_SD(2, rt)<br>StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr2..0) !=  03 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>datadouble <- COP_SD(2, rt)<br>StoreMemory (uncached, DOUBLEWORD, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "SDL", name: "Store Doubleword Left", architecture: "MIPS III", bits: [[31, 26, "SDL", "101100"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SDL rt, offset(base) [I-type]", purpose: "To store the most-significant part of a doubleword to an unaligned memory address.", description: "memory[base+offset] <- Some_Bytes_From rt<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the most-significant of eight consecutive bytes forming a doubleword in memory (DW) starting at an arbitrary byte boundary. A part of DW, the most-significant one to eight bytes, is in the aligned doubleword containing EffAddr. The same number of most-significant (left) bytes of GPR rt are stored into these bytes of DW.<br>The figure below illustrates this operation for big-endian byte ordering. The eight consecutive bytes in 2..9 form an unaligned doubleword starting at location 2. A part of DW, six bytes, is contained in the aligned doubleword containing the most-significant byte at 2. First, SDL stores the six most-significant bytes of the source register into these bytes in memory. Next, the complementary SDR instruction stores the remainder of DW.<br><figure><br><img src=\"images/sdl1.png\" alt=\"Unaligned Doubleword Store with SDL and SDR\" width=\"600\"><br><figcaption>Unaligned Doubleword Store with SDL and SDR.</figcaption><br></figure><br>The bytes stored from the source register to memory depend on both the offset of the effective address within an aligned doubleword, i.e. the low three bits of the address (vAddr2..0), and the current byte ordering mode of the processor (big- or little-endian). The table below shows the bytes stored for every combination of offset and byte ordering.<br><figure><br><img src=\"images/sdl2.png\" alt=\"Bytes Stored by SDL Instruction\" width=\"600\"><br><figcaption>Bytes Stored by SDL Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>If BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- vAddr2..0 xor BigEndianCPU3<br>datadouble <- 056-8*byte || GPR[rt]63..56-8*byte<br>StoreMemory (uncached, byte, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "SDR", name: "Store Doubleword Right", architecture: "MIPS III", bits: [[31, 26, "SDR", "101101"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SDR rt, offset(base) [I-type]", purpose: "To store the least-significant part of a doubleword to an unaligned memory address.", description: "memory[base+offset] <- Some_Bytes_From rt<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the least-significant of eight consecutive bytes forming a doubleword in memory (DW) starting at an arbitrary byte boundary. A part of DW, the least-significant one to eight bytes, is in the aligned doubleword containing EffAddr. The same number of least-significant (right) bytes of GPR rt are stored into these bytes of DW.<br>The figure below illustrates this operation for big-endian byte ordering. The eight consecutive bytes in 2..9 form an unaligned doubleword starting at location 2. A part of DW, two bytes, is contained in the aligned doubleword containing the least- significant byte at 9. First, SDR stores the two least-significant bytes of the source register into these bytes in memory. Next, the complementary SDL stores the remainder of DW.<br><figure><br><img src=\"images/sdr1.png\" alt=\"Unaligned Doubleword Store with SDR and SDL\" width=\"600\"><br><figcaption>Unaligned Doubleword Store with SDR and SDL.</figcaption><br></figure><br>The bytes stored from the source register to memory depend on both the offset of the effective address within an aligned doubleword, i.e. the low three bits of the address (vAddr2..0), and the current byte ordering mode of the processor (big- or little-endian). The table below shows the bytes stored for every combination of offset and byte ordering.<br><figure><br><img src=\"images/sdr2.png\" alt=\"Bytes Stored by SDR Instruction\" width=\"600\"><br><figcaption>Bytes Stored by SDR Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>If BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..3 || 03<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU3<br>datadouble <- GPR[rt]63-8*byte || 08*byte<br>StoreMemory (uncached, DOUBLEWORD-byte, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Bus Error<br>Address Error<br>Reserved Instruction", programming_notes: "", implementation_notes: ""},
{symbol: "SH", name: "Store Halfword", architecture: "MIPS I", bits: [[31, 26, "SH", "101001"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SH rt, offset(base) [I-type]", purpose: "To store a halfword to memory.", description: "memory[base+offset] <- rt<br>The least-significant 16-bit halfword of register rt is stored in memory at the location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If the least-significant bit of the address is non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order bit of the offset field must be zero. If it is not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..2 || (pAddr1..0 xor (ReverseEndian || 0))<br>byte <- vAddr1..0 xor (BigEndianCPU || 0)<br>dataword <- GPR[rt]31-8*byte..0 || 08*byte<br>StoreMemory (uncached, HALFWORD, dataword, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr0) !=  0 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian2 || 0))<br>byte <- vAddr2..0 xor (BigEndianCPU2 || 0)<br>datadouble <- GPR[rt]63-8*byte..0 || 08*byte<br>StoreMemory (uncached, HALFWORD, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "SLL", name: "Shift Word Left Logical", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "SLL", "000000"]], format: "SLL rd, rt, sa [R-type]", purpose: "To left shift a word by a fixed number of bits.", description: "rd <- rt << sa<br>The contents of the low-order 32-bit word of GPR rt are shifted left, inserting zeroes into the emptied bits; the word result is placed in GPR rd. The bit shift count is specified by sa. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "None.", operation: "s <- sa<br>temp <- GPR[rt](31-s)..0 || 0s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "Unlike nearly all other word operations the input operand does not have to be a properly sign-extended word value to produce a valid sign-extended 32-bit result. The result word is always sign extended into a 64-bit destination register; this instruction with a zero shift amount truncates a 64-bit value to 32 bits and sign extends it.<br>Some assemblers, particularly 32-bit assemblers, treat this instruction with a shift amount of zero as a NOP and either delete it or replace it with an actual NOP.", implementation_notes: ""},
{symbol: "SLLV", name: "Shift Word Left Logical Variable", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SLLV", "000100"]], format: "SLLV rd, rt, rs [R-type]", purpose: "To left shift a word by a variable number of bits.", description: "rd <- rt << rs<br>The contents of the low-order 32-bit word of GPR rt are shifted left, inserting zeroes into the emptied bits; the result word is placed in GPR rd. The bit shift count is specified by the low-order five bits of GPR rs. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "None.", operation: "s <- GP[rs]4..0<br>temp <- GPR[rt](31-s)..0 || 0s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "Unlike nearly all other word operations the input operand does not have to be a properly sign-extended word value to produce a valid sign-extended 32-bit result. The result word is always sign extended into a 64-bit destination register; this instruction with a zero shift amount truncates a 64-bit value to 32 bits and sign extends it.<br>Some assemblers, particularly 32-bit assemblers, treat this instruction with a shift amount of zero as a NOP and either delete it or replace it with an actual NOP.", implementation_notes: ""},
{symbol: "SLT", name: "Set On Less Than", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SLT", "101010"]], format: "SLT rd, rs, rt [R-type]", purpose: "To record the result of a less-than comparison.", description: "rd <- (rs < rt)<br>Compare the contents of GPR rs and GPR rt as signed integers and record the Boolean result of the comparison in GPR rd. If GPR rs is less than GPR rt the result is 1 (true), otherwise 0 (false).<br>The arithmetic comparison does not cause an Integer Overflow exception.", restrictions: "None.", operation: "if GPR[rs] < GPR[rt] then<br>&emsp;GPR[rd] <- 0GPRLEN-1 || 1<br>else<br>&emsp;GPR[rd] <- 0GPRLEN<br>endif", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SLTI", name: "Set on Less Than Immediate", architecture: "MIPS I", bits: [[31, 26, "SLTI", "001010"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "SLTI rt, rs, immediate [I-type]", purpose: "To record the result of a less-than comparison with a constant.", description: "rt <- (rs < immediate)<br>Compare the contents of GPR rs and the 16-bit signed immediate as signed integers and record the Boolean result of the comparison in GPR rt. If GPR rs is less than immediate the result is 1 (true), otherwise 0 (false).<br>The arithmetic comparison does not cause an Integer Overflow exception.", restrictions: "None.", operation: "if GPR[rs] < sign_extend(immediate) then<br>&emsp;GPR[rd] <- 0GPRLEN-1|| 1<br>else<br>&emsp;GPR[rd] <- 0GPRLEN<br>endif", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SLTIU", name: "Set on Less Than Immediate Unsigned", architecture: "MIPS I", bits: [[31, 26, "SLTIU", "001011"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "SLTIU rt, rs, immediate [I-type]", purpose: "To record the result of an unsigned less-than comparison with a constant.", description: "rt <- (rs < immediate)<br>Compare the contents of GPR rs and the sign-extended 16-bit immediate as unsigned integers and record the Boolean result of the comparison in GPR rt. If GPR rs is less than immediate the result is 1 (true), otherwise 0 (false).<br>Because the 16-bit immediate is sign-extended before comparison, the instruction is able to represent the smallest or largest unsigned numbers. The representable values are at the minimum [0, 32767] or maximum [max_unsigned-32767, max_unsigned] end of the unsigned range.<br>The arithmetic comparison does not cause an Integer Overflow exception.", restrictions: "None.", operation: "if (0 || GPR[rs]) < (0 || sign_extend(immediate)) then<br>&emsp;GPR[rd] <- 0GPRLEN-1 || 1<br>else<br>&emsp;GPR[rd] <- 0GPRLEN<br>endif", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SLTU", name: "Set on Less Than Unsigned", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SLTU", "101011"]], format: "SLTU rd, rs, rt [R-type]", purpose: "To record the result of an unsigned less-than comparison.", description: "rd <- (rs < rt)<br>Compare the contents of GPR rs and GPR rt as unsigned integers and record the Boolean result of the comparison in GPR rd. If GPR rs is less than GPR rt the result is 1 (true), otherwise 0 (false).<br>The arithmetic comparison does not cause an Integer Overflow exception.", restrictions: "None.", operation: "if (0 || GPR[rs]) < (0 || GPR[rt]) then<br>&emsp;GPR[rd] <- 0GPRLEN-1 || 1<br>else<br>&emsp;GPR[rd] <- 0GPRLEN<br>endif", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SRA", name: "Shift Word Right Arithmetic", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "SRA", "000011"]], format: "SRA rd, rt, sa [R-type]", purpose: "To arithmetic right shift a word by a fixed number of bits.", description: "rd <- rt >> sa (arithmetic)<br>The contents of the low-order 32-bit word of GPR rt are shifted right, duplicating the sign-bit (bit 31) in the emptied bits; the word result is placed in GPR rd. The bit shift count is specified by sa. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "On 64-bit processors, if GPR rt does not contain a sign-extended 32-bit value (bits 63..31 equal) then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rt])) then UndefinedResult() endif<br>s <- sa<br>temp <- (GPR[rt]31)s || GPR[rt]31..s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SRAV", name: "Shift Word Right Arithmetic Variable", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SRAV", "000111"]], format: "SRAV rd, rt, rs [R-type]", purpose: "To arithmetic right shift a word by a variable number of bits.", description: "rd <- rt >> rs (arithmetic)<br>The contents of the low-order 32-bit word of GPR rt are shifted right, duplicating the sign-bit (bit 31) in the emptied bits; the word result is placed in GPR rd. The bit shift count is specified by the low-order five bits of GPR rs. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "On 64-bit processors, if GPR rt does not contain a sign-extended 32-bit value (bits 63..31 equal) then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rt])) then UndefinedResult() endif<br>s <- GPR[rs]4..0<br>temp <- (GPR[rt]31)s || GPR[rt]31..s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SRL", name: "Shift Word Right Logical", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "0", "00000"],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "sa", ""],[5, 0, "SRL", "000010"]], format: "SRL rd, rt, sa [R-type]", purpose: "To logical right shift a word by a fixed number of bits.", description: "rd <- rt >> sa (logical)<br>The contents of the low-order 32-bit word of GPR rt are shifted right, inserting zeros into the emptied bits; the word result is placed in GPR rd. The bit shift count is specified by sa. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "On 64-bit processors, if GPR rt does not contain a sign-extended 32-bit value (bits 63..31 equal) then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rt])) then UndefinedResult() endif<br>s <- sa<br>temp <- 0s || GPR[rt]31..s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SRLV", name: "Shift Word Right Logical Variable", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SRLV", "000110"]], format: "SRLV rd, rt, rs [R-type]", purpose: "To logical right shift a word by a variable number of bits.", description: "rd <- rt >> rs (logical)<br>The contents of the low-order 32-bit word of GPR rt are shifted right, inserting zeros into the emptied bits; the word result is placed in GPR rd. The bit shift count is specified by the low-order five bits of GPR rs. If rd is a 64-bit register, the result word is sign-extended.", restrictions: "On 64-bit processors, if GPR rt does not contain a sign-extended 32-bit value (bits 63..31 equal) then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rt])) then UndefinedResult() endif<br>s <- GPR[rs]4..0<br>temp <- 0s || GPR[rt]31..s<br>GPR[rd] <- sign_extend(temp)", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "SUB", name: "Subtract Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SUB", "100010"]], format: "SUB rd, rs, rt [R-type]", purpose: "To subtract 32-bit integers. If overflow occurs, then trap.", description: "rd <- rs - rt<br>The 32-bit word value in GPR rt is subtracted from the 32-bit value in GPR rs to produce a 32-bit result. If the subtraction results in 32-bit 2's complement arithmetic overflow then the destination register is not modified and an Integer Overflow exception occurs. If it does not overflow, the 32-bit result is placed into GPR rd.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>temp <- GPR[rs] - GPR[rt]<br>if (32_bit_arithmetic_overflow) then<br>&emsp;SignalException(IntegerOverflow)<br>else<br>&emsp;GPR[rd] <- temp<br>endif", exceptions: "Integer Overflow", programming_notes: "SUBU performs the same arithmetic operation but, does not trap on overflow.", implementation_notes: ""},
{symbol: "SUBU", name: "Subtract Unsigned Word", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "SUBU", "100011"]], format: "SUBU rd, rs, rt [R-type]", purpose: "To subtract 32-bit integers.", description: "rd <- rs - rt<br>The 32-bit word value in GPR rt is subtracted from the 32-bit value in GPR rs and the 32-bit arithmetic result is placed into GPR rd.<br>No integer overflow exception occurs under any circumstances.", restrictions: "On 64-bit processors, if either GPR rt or GPR rs do not contain sign-extended 32-bit values (bits 63..31 equal), then the result of the operation is undefined.", operation: "if (NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])) then UndefinedResult() endif<br>temp <- GPR[rs] - GPR[rt]<br>GPR[rd] <- temp", exceptions: "None.", programming_notes: "The term \"unsigned\" in the instruction name is a misnomer; this operation is 32-bit modulo arithmetic that does not trap on overflow. It is appropriate for arithmetic which is not signed, such as address arithmetic, or integer arithmetic environments that ignore overflow, such as \"C\" language arithmetic.", implementation_notes: ""},
{symbol: "SW", name: "Store Word", architecture: "MIPS I", bits: [[31, 26, "SW", "101011"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SW rt, offset(base) [I-type]", purpose: "To store a word to memory.", description: "memory[base+offset] <- rt<br>The least-significant 32-bit word of register rt is stored in memory at the location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.", restrictions: "The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>dataword <- GPR[rt]<br>StoreMemory (uncached, WORD, dataword, pAddr, vAddr, DATA)<br>64-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>datadouble <- GPR[rt]63-8*byte || 08*byte<br>StoreMemory (uncached, WORD, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "SWC1", name: "Store Word From Coprocessor", architecture: "MIPS I", bits: [[31, 26, "SWC1", "111001"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SWC1 rt, offset(base) [I-type]", purpose: "To store a word from a coprocessor general register to memory.", description: "memory[base+offset] <- rt.<br>Coprocessor unit 1 supplies a 32-bit word which is stored at the memory location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The data supplied by each coprocessor is defined by the individual coprocessor specifications. The usual operation would read the data from coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>dataword <- COP_SW (1, rt)<br>StoreMemory (uncached, WORD, dataword, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>dataword <- COP_SW (1, rt)<br>datadouble <- 032-8*byte || dataword || 08*byte<br>StoreMemory (uncached, WORD, datadouble, pAddr, vAddr DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "SWC2", name: "Store Word From Coprocessor", architecture: "MIPS I", bits: [[31, 26, "SWC2", "111010"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SWC2 rt, offset(base) [I-type]", purpose: "To store a word from a coprocessor general register to memory.", description: "memory[base+offset] <- rt.<br>Coprocessor unit 2 supplies a 32-bit word which is stored at the memory location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The data supplied by each coprocessor is defined by the individual coprocessor specifications. The usual operation would read the data from coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>dataword <- COP_SW (2, rt)<br>StoreMemory (uncached, WORD, dataword, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>dataword <- COP_SW (2, rt)<br>datadouble <- 032-8*byte || dataword || 08*byte<br>StoreMemory (uncached, WORD, datadouble, pAddr, vAddr DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "SWC3", name: "Store Word From Coprocessor", architecture: "MIPS I", bits: [[31, 26, "SWC3", "111011"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SWC3 rt, offset(base) [I-type]", purpose: "To store a word from a coprocessor general register to memory.", description: "memory[base+offset] <- rt.<br>Coprocessor unit 3 supplies a 32-bit word which is stored at the memory location specified by the aligned effective address. The 16-bit signed offset is added to the contents of GPR base to form the effective address.<br>The data supplied by each coprocessor is defined by the individual coprocessor specifications. The usual operation would read the data from coprocessor general register rt.<br>Each MIPS architecture level defines up to 4 coprocessor units, numbered 0 to 3. The opcodes corresponding to coprocessors that are not defined by an architecture level may be used for other instructions.", restrictions: "Access to the coprocessors is controlled by system software. Each coprocessor has a \"coprocessor usable\" bit in the System Control coprocessor. The usable bit must be set for a user program to execute a coprocessor instruction. If the usable bit is not set, an attempt to execute the instruction will result in a Coprocessor Unusable exception. An unimplemented coprocessor must never be enabled. The result of executing this instruction for an unimplemented coprocessor when the usable bit is set, is undefined.<br>This instruction is not available for coprocessor 0, the System Control coprocessor, and the opcode may be used for other instructions.<br>The effective address must be naturally aligned. If either of the two least-significant bits of the address are non-zero, an Address Error exception occurs.<br>MIPS IV: The low-order 2 bits of the offset field must be zero. If they are not, the result of the instruction is undefined.", operation: "32-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>dataword <- COP_SW (3, rt)<br>StoreMemory (uncached, WORD, dataword, pAddr, vAddr, DATA)<br>64-bit processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>if (vAddr1..0) !=  02 then SignalException(AddressError) endif<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02)<br>byte <- vAddr2..0 xor (BigEndianCPU || 02)<br>dataword <- COP_SW (3, rt)<br>datadouble <- 032-8*byte || dataword || 08*byte<br>StoreMemory (uncached, WORD, datadouble, pAddr, vAddr DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Address Error<br>Reserved Instruction<br>Coprocessor Unusable", programming_notes: "", implementation_notes: ""},
{symbol: "SWL", name: "Store Word Left", architecture: "MIPS I", bits: [[31, 26, "SWL", "101010"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SWL rt, offset(base) [I-type]", purpose: "To store the most-significant part of a word to an unaligned memory address.", description: "memory[base+offset] <- rt<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the most-significant of four consecutive bytes forming a word in memory (W) starting at an arbitrary byte boundary. A part of W, the most-significant one to four bytes, is in the aligned word containing EffAddr. The same number of the most-significant (left) bytes from the word in GPR rt are stored into these bytes of W.<br>If GPR rt is a 64-bit register, the source word is the low word of the register.<br><figure><br><img src=\"images/lwl1.png\" alt=\"Unaligned Word Load using LWL and LWR\" width=\"600\"><br><figcaption>Unaligned Word Load using LWL and LWR.</figcaption><br></figure><br>The figure above illustrates this operation for big-endian byte ordering for 32-bit and 64-bit registers. The four consecutive bytes in 2..5 form an unaligned word starting at location 2. A part of W, two bytes, is contained in the aligned word containing the most-significant byte at 2. First, SWL stores the most-significant two bytes of the low-word from the source register into these two bytes in memory. Next, the complementary SWR stores the remainder of the unaligned word.<br><figure><br><img src=\"images/swl1.png\" alt=\"Unaligned Word Store using SWL and SWR\" width=\"600\"><br><figcaption>Unaligned Word Store using SWL and SWR.</figcaption><br></figure><br>The bytes stored from the source register to memory depend on both the offset of the effective address within an aligned word, i.e. the low two bits of the address (vAddr1..0), and the current byte ordering mode of the processor (big- or little-endian). The table below shows the bytes stored for every combination of offset and byte ordering.<br><figure><br><img src=\"images/swl2.png\" alt=\"Bytes Stored by SWL Instruction\" width=\"600\"><br><figcaption>Bytes Stored by SWL Instruction.</figcaption><br></figure>", restrictions: "", operation: "32-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..2 || (pAddr1..0 xor ReverseEndian2)<br>If BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>dataword <- 024-8*byte || GPR[rt]31..24-8*byte<br>StoreMemory (uncached, byte, dataword, pAddr, vAddr, DATA)<br>64-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>If BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>if (vAddr2 xor BigEndianCPU) = 0 then<br>&emsp;datadouble <- 032 || 024-8*byte || GPR[rt]31..24-8*byte<br>else<br>&emsp;datadouble <- 024-8*byte || GPR[rt]31..24-8*byte || 032<br>endif<br>StoreMemory(uncached, byte, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Bus Error<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "SWR", name: "Store Word Right", architecture: "MIPS I", bits: [[31, 26, "SWR", "101110"],[25, 21, "base", ""],[20, 16, "rt", ""],[15, 0, "offset", ""]], format: "SWR rt, offset(base) [I-type]", purpose: "To store the least-significant part of a word to an unaligned memory address.", description: "memory[base+offset] <- rt<br>The 16-bit signed offset is added to the contents of GPR base to form an effective address (EffAddr). EffAddr is the address of the least-significant of four consecutive bytes forming a word in memory (W) starting at an arbitrary byte boundary. A part of W, the least-significant one to four bytes, is in the aligned word containing EffAddr. The same number of the least-significant (right) bytes from the word in GPR rt are stored into these bytes of W.<br>If GPR rt is a 64-bit register, the source word is the low word of the register.<br><figure><br><img src=\"images/lwl1.png\" alt=\"Unaligned Word Load using LWL and LWR\" width=\"600\"><br><figcaption>Unaligned Word Load using LWL and LWR.</figcaption><br></figure><br>The figure above illustrates this operation for big-endian byte ordering for 32-bit and 64-bit registers. The four consecutive bytes in 2..5 form an unaligned word starting at location 2. A part of W, two bytes, is contained in the aligned word containing the least- significant byte at 5. First, SWR stores the least-significant two bytes of the low-word from the source register into these two bytes in memory. Next, the complementary SWL stores the remainder of the unaligned word.<br><figure><br><img src=\"images/swr1.png\" alt=\"Unaligned Word Store using SWR and SWL\" width=\"600\"><br><figcaption>Unaligned Word Store using SWR and SWL.</figcaption><br></figure><br>The bytes stored from the source register to memory depend on both the offset of the effective address within an aligned word, i.e. the low two bits of the address (vAddr1..0), and the current byte ordering mode of the processor (big- or little-endian). The tabel below shows the bytes stored for every combination of offset and byte ordering.<br><figure><br><img src=\"images/swr2.png\" alt=\"Bytes Stored by SWR Instruction\" width=\"600\"><br><figcaption>Bytes Stored by SWR Instruction.</figcaption><br></figure>", restrictions: "None.", operation: "32-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..2 || (pAddr1..0 xor ReverseEndian2)<br>BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>dataword <- GPR[rt]31-8*byte || 08*byte<br>StoreMemory (uncached, WORD-byte, dataword, pAddr, vAddr, DATA)<br>64-bit Processors:<br>vAddr <- sign_extend(offset) + GPR[base]<br>(pAddr, uncached) <- AddressTranslation (vAddr, DATA, STORE)<br>pAddr <- pAddr(PSIZE-1)..3 || (pAddr2..0 xor ReverseEndian3)<br>If BigEndianMem = 0 then<br>&emsp;pAddr <- pAddr(PSIZE-1)..2 || 02<br>endif<br>byte <- vAddr1..0 xor BigEndianCPU2<br>if (vAddr2 xor BigEndianCPU) = 0 then<br>&emsp;datadouble <- 032 || GPR[rt]31-8*byte..0 || 08*byte<br>else<br>&emsp;datadouble <- GPR[rt]31-8*byte..0 || 08*byte || 032<br>endif<br>StoreMemory(uncached, WORD-byte, datadouble, pAddr, vAddr, DATA)", exceptions: "TLB Refill, TLB Invalid<br>TLB Modified<br>Bus Error<br>Address Error", programming_notes: "", implementation_notes: ""},
{symbol: "SYNC", name: "Synchronize Shared Memory", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 11, "0", "000000000000000"],[10, 6, "stype", ""],[5, 0, "SYNC", "001111"]], format: "SYNC [R-type]", purpose: "To order loads and stores to shared memory in a multiprocessor system.", description: "To serve a broad audience, two descriptions are given. A simple description of SYNC that appeals to intuition is followed by a precise and detailed description.<br>SYNC affects only uncached and cached coherent loads and stores. The loads and stores that occur prior to the SYNC must be completed before the loads and stores after the SYNC are allowed to start.<br>Loads are completed when the destination register is written. Stores are completed when the stored value is visible to every other processor in the system.<br>If the stype field has a value of zero, every synchronizable load and store that occurs in the instruction stream prior to the SYNC instruction must be globally performed before any synchronizable load or store that occurs after the SYNC may be performed with respect to any other processor or coherent I/O module.<br>Sync does not guarantee the order in which instruction fetches are performed.<br>The stype values 1-31 are reserved; they produce the same result as the value zero.<br>Synchronizable: A load or store instruction is synchronizable if the load or store occurs to a physical location in shared memory using a virtual location with a memory access type of either uncached or cached coherent. Shared memory is memory that can be accessed by more than one processor or by a coherent I/O system module.<br>Performed load: A load instruction is performed when the value returned by the load has been determined. The result of a load on processor A has been determined with respect to processor or coherent I/O module B when a subsequent store to the location by B cannot affect the value returned by the load. The store by B must use the same memory access type as the load.<br>Performed store: A store instruction is performed when the store is observable. A store on processor A is observable with respect to processor or coherent I/O module B when a subsequent load of the location by B returns the value written by the store. The load by B must use the same memory access type as the store.<br>Globally performed load: A load instruction is globally performed when it is performed with respect to all processors and coherent I/O modules capable of storing to the location.<br>Globally performed store: A store instruction is globally performed when it is globally observable. It is globally observable when it observable by all processors and I/O modules capable of loading from the location.<br>Coherent I/O module: A coherent I/O module is an Input/Output system component that performs coherent Direct Memory Access (DMA). It reads and writes memory independently as though it were a processor doing loads and stores to locations with a memory access type of cached coherent.", restrictions: "The effect of SYNC on the global order of the effects of loads and stores for memory access types other than uncached and cached coherent is not defined.", operation: "SyncOperation(stype)", exceptions: "Reserved Instruction", programming_notes: "A processor executing load and store instructions observes the effects of the loads and stores that use the same memory access type in the order that they occur in the instruction stream; this is known as program order. A parallel program has multiple instruction streams that can execute at the same time on different processors. In multiprocessor (MP) systems, the order in which the effects of loads and stores are observed by other processors, the global order of the loads and stores, determines the actions necessary to reliably share data in parallel programs.<br>When all processors observe the effects of loads and stores in program order, the system is strongly ordered. On such systems, parallel programs can reliably share data without explicit actions in the programs. For such a system, SYNC has the same effect as a NOP. Executing SYNC on such a system is not necessary, but is also not an error.<br>If a multiprocessor system is not strongly ordered, the effects of load and store instructions executed by one processor may be observed out of program order by other processors. On such systems, parallel programs must take explicit actions in order to reliably share data. At critical points in the program, the effects of loads and stores from an instruction stream must occur in the same order for all processors. SYNC separates the loads and stores executed on the processor into two groups and the effects of these groups are seen in program order by all processors. The effect of all loads and stores in one group is seen by all processors before the effect of any load or store in the other group. In effect, SYNC causes the system to be strongly ordered for the executing processor at the instant that the SYNC is executed.<br>Many MIPS-based multiprocessor systems are strongly ordered or have a mode in which they operate as strongly ordered for at least one memory access type. The MIPS architecture also permits MP systems that are not strongly ordered. SYNC enables the reliable use of shared memory on such systems. A parallel program that does not use SYNC will generally not operate on a system that is not strongly ordered, however a program that does use SYNC will work on both types of systems. System-specific documentation will describe the actions necessary to reliably share data in parallel programs for that system.<br>The behavior of a load or store using one memory access type is undefined if a load or store was previously made to the same physical location using a different memory access type. The presence of a SYNC between the references does not alter this behavior.<br>SYNC affects the order in which the effects of load and store instructions appears to all processors; it not generally affect the physical memory-system ordering or synchronization issues that arise in system programming. The effect of SYNC on implementation specific aspects of the cached memory system, such as writeback buffers, is not defined. The effect of SYNC on reads or writes to memory caused by privileged implementation-specific instructions, such as CACHE, is not defined.<br>Prefetch operations have no effects detectable by user-mode programs so ordering the effects of prefetch operations is not meaningful.", implementation_notes: "There may be side effects of uncached loads and stores that affect cached coherent load and store operations. To permit the reliable use of such side effects, buffered uncached stores that occur before the SYNC must be written to memory before cached coherent loads and stores after the SYNC may be performed."},
{symbol: "SYSCALL", name: "System Call", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 6, "Code", ""],[5, 0, "SYSCALL", "001100"]], format: "SYSCALL [R-type]", purpose: "To cause a System Call exception.", description: "A system call exception occurs, immediately and unconditionally transferring control to the exception handler.<br>The code field is available for use as software parameters, but is retrieved by the exception handler only by loading the contents of the memory word containing the instruction.", restrictions: "None.", operation: "SignalException(SystemCall)", exceptions: "System Call", programming_notes: "", implementation_notes: ""},
{symbol: "TEQ", name: "Trap if Equal", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TEQ", "110100"]], format: "TEQ rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs = rt) then Trap<br>Compare the contents of GPR rs and GPR rt as signed integers; if GPR rs is equal to GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if GPR[rs] = GPR[rt] then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TEQI", name: "Trap if Equal Immediate", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TEQI", "01100"],[15, 0, "immediate", ""]], format: "TEQI rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs = immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit signed immediate as signed integers; if GPR rs is equal to immediate then take a Trap exception.", restrictions: "None.", operation: "if GPR[rs] = sign_extend(immediate) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TGE", name: "Trap if Greater or Equal", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TGE", "110000"]], format: "TGE rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs >= rt) then Trap.<br>Compare the contents of GPR rs and GPR rt as signed integers; if GPR rs is greater than or equal to GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if GPR[rs] >= GPR[rt] then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TGEI", name: "Trap if Greater or Equal Immediate", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TGEI", "01000"],[15, 0, "immediate", ""]], format: "TGEI rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs >= immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit signed immediate as signed integers; if GPR rs is greater than or equal to immediate then take a Trap exception.", restrictions: "None.", operation: "if GPR[rs] >= sign_extend(immediate) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TGEIU", name: "Trap If Greater Or Equal Immediate Unsigned", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TGEIU", "01001"],[15, 0, "immediate", ""]], format: "TGEIU rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs >= immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit sign-extended immediate as unsigned integers; if GPR rs is greater than or equal to immediate then take a Trap exception.<br>Because the 16-bit immediate is sign-extended before comparison, the instruction is able to represent the smallest or largest unsigned numbers. The representable values are at the minimum [0, 32767] or maximum [max_unsigned-32767, max_unsigned] end of the unsigned range.", restrictions: "None.", operation: "if (0 || GPR[rs]) >= (0 || sign_extend(immediate)) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TGEU", name: "Trap If Greater or Equal Unsigned", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TGEU", "110001"]], format: "TGEU rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs >= rt) then Trap<br>Compare the contents of GPR rs and GPR rt as unsigned integers; if GPR rs is greater than or equal to GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if (0 || GPR[rs]) >= (0 || GPR[rt]) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TLT", name: "Trap if Less Than", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TLT", "110010"]], format: "TLT rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs < rt) then Trap<br>Compare the contents of GPR rs and GPR rt as signed integers; if GPR rs is less than GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if GPR[rs] < GPR[rt] then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TLTI", name: "Trap if Less Than Immediate", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TLTI", "01010"],[15, 0, "immediate", ""]], format: "TLTI rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs < immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit signed immediate as signed integers; if GPR rs is less than immediate then take a Trap exception.", restrictions: "None.", operation: "if GPR[rs] < sign_extend(immediate) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TLTIU", name: "Trap if Less Than Immediate Unsigned", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TLTIU", "01011"],[15, 0, "immediate", ""]], format: "TLTIU rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs < immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit sign-extended immediate as unsigned integers; if GPR rs is less than immediate then take a Trap exception.<br>Because the 16-bit immediate is sign-extended before comparison, the instruction is able to represent the smallest or largest unsigned numbers. The representable values are at the minimum [0, 32767] or maximum [max_unsigned-32767, max_unsigned] end of the unsigned range.", restrictions: "None.", operation: "if (0 || GPR[rs]) < (0 || sign_extend(immediate)) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TLTU", name: "Trap if Less Than Unsigned", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TLTU", "110011"]], format: "TLTU rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs < rt) then Trap<br>Compare the contents of GPR rs and GPR rt as unsigned integers; if GPR rs is less than GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if (0 || GPR[rs]) < (0 || GPR[rt]) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TNE", name: "Trap if Not Equal", architecture: "MIPS II", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 6, "code", ""],[5, 0, "TNE", "110110"]], format: "TNE rs, rt [R-type]", purpose: "To compare GPRs and do a conditional Trap.", description: "if (rs !=  rt) then Trap<br>Compare the contents of GPR rs and GPR rt as signed integers; if GPR rs is not equal to GPR rt then take a Trap exception.<br>The contents of the code field are ignored by hardware and may be used to encode information for system software. To retrieve the information, system software must load the instruction word from memory.", restrictions: "None.", operation: "if GPR[rs] !=  GPR[rt] then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "TNEI", name: "Trap if Not Equal Immediate", architecture: "MIPS II", bits: [[31, 26, "REGIMM", "000001"],[25, 21, "rs", ""],[20, 16, "TNEI", "01110"],[15, 0, "immediate", ""]], format: "TNEI rs, immediate [I-type]", purpose: "To compare a GPR to a constant and do a conditional Trap.", description: "if (rs !=  immediate) then Trap<br>Compare the contents of GPR rs and the 16-bit signed immediate as signed integers; if GPR rs is not equal to immediate then take a Trap exception.", restrictions: "None.", operation: "if GPR[rs] !=  sign_extend(immediate) then<br>&emsp;SignalException(Trap)<br>endif", exceptions: "Reserved Instruction<br>Trap", programming_notes: "", implementation_notes: ""},
{symbol: "XOR", name: "Exclusive OR", architecture: "MIPS I", bits: [[31, 26, "SPECIAL", "000000"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 11, "rd", ""],[10, 6, "0", "00000"],[5, 0, "XOR", "100110"]], format: "XOR rd, rs, rt [R-type]", purpose: "To do a bitwise logical EXCLUSIVE OR.", description: "rd <- rs XOR rt<br>Combine the contents of GPR rs and GPR rt in a bitwise logical exclusive OR operation and place the result into GPR rd.", restrictions: "None.", operation: "GPR[rd] <- GPR[rs] xor GPR[rt]", exceptions: "None.", programming_notes: "", implementation_notes: ""},
{symbol: "XORI", name: "Exclusive OR Immediate", architecture: "MIPS I", bits: [[31, 26, "XORI", "001110"],[25, 21, "rs", ""],[20, 16, "rt", ""],[15, 0, "immediate", ""]], format: "XORI rt, rs, immediate [I-type]", purpose: "To do a bitwise logical EXCLUSIVE OR with a constant.", description: "rt <- rs XOR immediate<br>Combine the contents of GPR rs and the 16-bit zero-extended immediate in a bitwise logical exclusive OR operation and place the result into GPR rt.", restrictions: "None.", operation: "GPR[rt] <- GPR[rs] xor zero_extend(immediate)", exceptions: "None.", programming_notes: "", implementation_notes: ""}
];

/* checks if the hex entered has the correct number of bits */
function checkHex(hex) {
    if (hex.length == 8) {
	return true;
    }
    else {
	return false;
    }
}

/* converts binary string and return a hex string */
function binaryToHex(binaryValue){
    // if binary value is not multiple of 4, add zeros in the left
    missingBits = binaryValue.length % 4;
    for(i = 0; i < missingBits; i++){
	binaryValue = "0" + binaryValue;
    }
    
    var hexValue = "";
    for(j = 0; j < binaryValue.length; j+=4){
	if(binaryValue.substring(j,j+4).indexOf('X') === -1){
	    hexValue = hexValue + binaryToHexTable[binaryValue.substring(j,j+4)];
	}
	else{
	    hexValue = hexValue + "X";
	}
    }
    return hexValue;
}

function searchIns(bin){ 
    var opcode = bin.substring(0,6);
    var instructionObject = {};
    // search funct codes
    if (opcode == "000000"){	
	var funct = bin.substring(26,33);
	for(i = 0; i < instructions.length; i++){
	    if(instructions[i].bits[(instructions[i].bits.length)-1][3] == funct
	       && instructions[i].bits[0][3] == opcode){
		instructionObject = instructions[i];
		break;
	    }
	}
    }
    // else if REGIMM
    else if (opcode == "000001"){
	var regimm = bin.substring(11,16);
	for(i = 0; i < instructions.length; i++){
	    if(instructions[i].bits.length >= 3
	       && instructions[i].bits[2][3] == regimm
	       && instructions[i].bits[0][3] == opcode){
		instructionObject = instructions[i];
		break;
	    }
	}
    }
    // search opcodes
    else {
	for(i = 0; i < instructions.length; i++){
	    if(instructions[i].bits[0][3] == opcode){
		instructionObject = instructions[i];
		break;
	    }
	}
    }
    return instructionObject;
}

/* Function to convert hex to binary.  It takes in a string with the hex value */
function hexToBinary(hex){
    if (checkHex(hex) == true) {
	var i, ret = '';
	for (i = 0; i < hex.length; i += 1) {    
	    if (hexTable.hasOwnProperty(hex[i])) {
		ret += hexTable[hex[i]];
	    } else {
		ret = false;
	    }
	}
	if (ret == false){
	    process.stderr.write ("Error: Incorrect input. <BR> Please check to make sure you are entering valid hex numbers.");
	}
	else{
	    return ret;
	}
    }
    else {
	process.stderr.write ("Error: Incorrect number of bits. <BR> Please check that you have the correct number of bits.");
    }
}

/* Function to determine which mips instruction is given */
function binaryToMips(hex) {

    var bin = hexToBinary(hex);
    var opcode = bin.substring(0,6);
    var result = "";
    
    // search for the instruction object
    var insObj = searchIns(bin);

    // check if the instruction was found
    // if it was not found, print an error message and return
    if(typeof insObj.format === 'undefined')
		return "Not found";

    // build bits table for typed instruction
    var bits = [];
    for(i = 0; i < insObj.bits.length; i++){ // for every field of the instruction
	bits[i] = [];
	bits[i][0] = insObj.bits[i][0]; // copy starting bit
	bits[i][1] = insObj.bits[i][1]; // copy ending bit

	// get field content
	if(insObj.bits[i][3] == ""){
	    bits[i][3] = bin.substring(32 - insObj.bits[i][0] - 1, 32 - insObj.bits[i][1]); // get field content from binary value
	}
	else{
	    bits[i][3] =  insObj.bits[i][3]; // copy field content
	}

	// get field name
	if(insObj.bits[i][2].match(/(rd|rs|rt|base)/) == null){
	    bits[i][2] = insObj.bits[i][2]; // copy field name
	}
	else{
	    bits[i][2] = registerTable[bits[i][3]];
	}
    }

    // remove comas, parenthesis and square brackets of the format string
    var format = insObj.format;
    format = format.replace(/\[[^\]]+\]/g, ''); 
    format = format.replace(/,/g, ' '); 
    format = format.replace(/\(/g, ' '); 
    format = format.replace(/\)/g, ' '); 

    // get all the pieces of the format string and typed instruction (consider whitespaces as separators)
    var formatPieces = format.replace(/\s+/g,' ').trim().split(' ');

    // get the registers and immediates values and put them in an array
    for(i = 1; i < formatPieces.length; i++){
	for(j = 0; j < bits.length; j++){
	    if(insObj.bits[j][2] == formatPieces[i]){
		if(formatPieces[i].match(/(rd|rs|rt|base)/) != null){
		    formatPieces[i] = bits[j][2];
		}
		else{
		    formatPieces[i] = "0x" + binaryToHex(bits[j][3]);
		}
	    }
	}
    }

    // print the typed instruction binary and hexadecimal value and its bits table
    var result = "";
    result += formatPieces.join(' ');
    //result += "<h3>Binary: " + bin + "</h3>";
    //result += "<h3>Hex: 0x" + hex + "</h3>";
    
    return result;
}

String.prototype.replaceAt=function(index, character) {
    return this.substr(0, index) + character + this.substr(index+character.length);
}


function interistingInstruction (instr) {

	if (instr.search ("BEQ")   != -1) return true;
	if (instr.search ("BNE")   != -1) return true;
	if (instr.search ("BGTZ")  != -1) return true;
	if (instr.search ("BGTEZ") != -1) return true;
	if (instr.search ("BLTZ")  != -1) return true;
	if (instr.search ("BLEZ")  != -1) return true;
	if (instr.search ("J ")    != -1) return true;
	if (instr.search ("JR")    != -1) return true;
	if (instr.search ("JALR")  != -1) return true;
	if (instr.search ("JAL")   != -1) return true;

	return false;
}

var bruteforceMipsInstruction = function (n, leftPart, rightPart) {

	var tmp = "";
	var instr = "";
	var i = 0;
	var possib_attack = false;

	for (; i < rightPart.length ; i++) {

		tmp = "" + rightPart;
		if (tmp[i] == "0") tmp = tmp.replaceAt (i, "1");
		else tmp = tmp.replaceAt (i, "0");

		if (n > 1) {
			arguments.callee (n - 1, 
				leftPart + tmp.substring (0, i + 1), 
				tmp.substring (i + 1, tmp.length));

		}
		else {
			bin = leftPart + tmp;
			instr = binaryToMips (binaryToHex (bin));
			if (interistingInstruction (instr)) {
				process.stdout.write (binaryToHex (bin) + ":" + bin + ": " + instr + "\n");
			}
		}
	}

	return;
};

function main (argv) {

	/* usage */
	if (argv.length != 4) {
		process.stderr.write ("Usage : " + argv[0] + " " + argv[1] + " n_bit_to_attack hex_code\n");
		return;
	}

	n = argv[2];
	hex = argv[3];

    /* Check to see if hex has '0x' or 'x' at beginnig of value */
    if (hex.charAt(0) == 'x' || hex.charAt(0) == 'X')
		hex = hex.substring(1);
    else if(hex.charAt(1) == 'x' || hex.charAt(1) == 'X')
		hex = hex.substring(2);

	bruteforceMipsInstruction (n, "", hexToBinary (hex));
}

main (process.argv);

